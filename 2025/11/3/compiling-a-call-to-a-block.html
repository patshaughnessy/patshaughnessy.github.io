<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Compiling a Call to a Block - Pat Shaughnessy</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/assets/css/normalize.css"><link rel="stylesheet" href="/assets/css/skeleton.css"><link rel="alternate" type="application/atom+xml" title="Pat Shaughnessy - Feed" href="http://feeds2.feedburner.com/patshaughnessy"><link rel="icon" type="image/png" href="images/favicon.png"></head><body><div id="banner"><a href="/"><span id="title">Pat Shaughnessy</span><span id="tagline"> blogger, rubyist, aspiring author</span></a></div><div style="margin-top: 35px"><div class="ten columns"><div class="container"><div class="row"><article class="post"><header><h1>Compiling a Call to a Block</h1><div class="metadata">November 3rd 2025&nbsp;&mdash;&nbsp;<a href="#disqus_thread" data-disqus-identifier="https://patshaughnessy.net/2025/11/3/compiling-a-call-to-a-block">&nbsp; Comments and &nbsp; Reactions</a></div></header><section class="content"><p>I've started working on a new edition of <a
href="https://patshaughnessy.net/ruby-under-a-microscope">Ruby Under a
Microscope</a> that covers Ruby 3.x. I'm working on this in my spare time, so it
will take a while. Leave a comment or <a
href="mailto:pat@patshaughnessy.net?subject=Ruby Under a Microscope Update">drop
me a line</a> and I'll email you when it's finished.</p>
<p>This week's excerpt is from Chapter 2, about Ruby's compiler. Whenever I think
about it, I'm always suprised that Ruby has a compiler like C, Java or any other
programming language. The only difference is that we don't normally interact
with Ruby's compiler directly.</p>
<p>The developers who contributed Ruby's new parser, Prism, also had to rewrite
the Ruby compiler because Prism now produces a completely different, redesigned
abstract syntax tree (AST). Chapter 2's outline is more or less the same as it
was in 2014, but I redrew all of the diagrams and updated much of the text to
match the new AST nodes and other changes for Prism.</p>
<h2>Chapter 2: Compilation</h2>
<div style="font-size: small">
<table id="toc">
	<tr>
		<td>The Ruby Compiler</td><td>4</td>
	</tr>
	<tr>
		<td>Ruby 3.2 Introduces a Just-In-Time (JIT) Compiler </td><td>5</td>
	</tr>
	<tr>
		<td>How Ruby Compiles a Simple Script</td><td>6</td>
	</tr>
	<tr>
		<td>Scope AST Nodes</td><td>7</td>
	</tr>
	<tr>
		<td>Compiling a Simple AST</td><td>8</td>
	</tr>
	<tr>
		<td>Compiling a Call to a Block</td><td>12</td>
	</tr>
	<tr>
		<td>How Ruby Iterates Through the AST</td><td>16</td>
	</tr>
	<tr>
		<td>Experiment 2-1: Displaying YARV Instructions</td><td>19</td>
	</tr>
	<tr>
		<td>The Local Table</td><td>21</td>
	</tr>
	<tr>
		<td>Compiling Optional Arguments</td><td>23</td>
	</tr>
	<tr>
		<td>Compiling Keyword Arguments</td><td>24</td>
	</tr>
	<tr>
		<td>Unnamed Local Variables</td><td>25</td>
	</tr>
	<tr>
		<td>Experiment 2-2: Displaying the Local Table</td><td>28</td>
	</tr>
	<tr>
		<td>Summary</td><td>30</td>
	</tr>
</table>
</div>
<h2>Compiling a Call to a Block</h2>
<p>Next, let’s compile my <span class="code">10.times</span> do example from
Listing 1-1 in Chapter 1 (see Listing 2-2).</p>
<pre style="background-color:#ffffff;">
<span style="color:#d08770;">10</span><span style="color:#000000;">.times </span><span style="color:#a71d5d;">do </span><span style="color:#4f5b66;">|</span><span style="color:#000000;">n</span><span style="color:#4f5b66;">|
</span><span style="color:#000000;">  puts n
</span><span style="color:#a71d5d;">end</span></pre>

<div style="font-style: italic; font-size: small; margin: -20px 0 20px 0">
 Listing 2-2: A simple script that calls a block (repeated from Listing 1-1)
</div>
<p>Notice that this example contains a block parameter to the <span
class="code">times</span> method. This is interesting because it will give us a
chance to see how the Ruby compiler handles blocks. Figure 2-13 shows the AST
for the <span class="code">10.times do</span> example again.</p>
<div style="padding: 8px 30px 30px 0px; text-align: center; line-height:18px">
<img width="100%" src="https://patshaughnessy.net/assets/2025/11/3/Figure-2-13.svg"><br/>
<span style="font-style: italic; font-size: small">
Figure 2-13: A simplified view of the AST for the call to 10.times, passing a block
</span>
</div>
<p>The left side of Figure 2-13 shows the AST for the <span
class="code">10.times</span> function call: the call node and the receiver 10,
represented by integer node. On the right, Figure 2-13 shows the beginning of
the AST for the block: <span class="code">do |n| puts n end</span>, represented
by the block node. You can see Ruby has added a scope node on both sides, since
there are two lexical scopes in Listing 2-2: the top level and the block.  Let’s
break down how Ruby compiles the main portion of the script shown on the left of
Figure 2-13. As before, Ruby starts with the first <span
class="code">PM_NODE_SCOPE</span> and creates a new snippet of YARV instructions,
as shown in Figure 2-14.</p>
<div style="padding: 8px 30px 30px 0px; text-align: center; line-height:18px">
<img width="75%" src="https://patshaughnessy.net/assets/2025/11/3/Figure-2-14.svg"><br/>
<span style="font-style: italic; font-size: small">
Figure 2-14: Each PM_SCOPE_NODE is compiled into a new snippet of YARV instructions.
</span>
</div>
<p>Next, Ruby steps down the AST nodes to <span class="code">PM_CALL_NODE,</span>
as shown in Figure 2-15.</p>
<div style="padding: 8px 30px 30px 0px; text-align: center; line-height:18px">
<img width="75%" src="https://patshaughnessy.net/assets/2025/11/3/Figure-2-15.svg"><br/>
<span style="font-style: italic; font-size: small">
Figure 2-15: Ruby stepping through an AST
</span>
</div>
<p>At this point, there is still no code generated, but notice in Figure 2-13 that
two arrows lead from <span class="code">PM_CALL_NODE</span>: one to <span
class="code">PM_INTEGER_NODE</span>, which represents the 10 in the <span
class="code">10.times</span> call, and another to the inner block. Ruby will
first continue down the AST to the integer node and compile the <span
class="code">10.times</span> method call.  The resulting YARV code, following
the same receiver-arguments-message pattern we saw in Figures 2-7 through 2-11,
is shown in Figure 2-16.</p>
<div style="padding: 8px 30px 30px 0px; text-align: center; line-height:18px">
<img width="75%" src="https://patshaughnessy.net/assets/2025/11/3/Figure-2-16.svg"><br/>
<span style="font-style: italic; font-size: small">
Figure 2-16: Ruby compiles the 10.times method call.
</span>
</div>
<p>Notice that the new YARV instructions shown in Figure 2-16 push the receiver
(the integer object 10) onto the stack first, after which Ruby generates an
instruction to execute the <span class="code">times</span> method call. But
notice, too, the <span class="code">block in &lt;main&gt;</span> argument in the
<span class="code">send</span> instruction. This indicates that the method call
also contains a block argument: <span class="code">do |n| puts n end</span>. In
this example, the arrow from <span class="code">PM_CALL_NODE</span> to the
second <span class="code">PM_SCOPE_NODE</span> has caused the Ruby compiler to
include this block argument.  Ruby continues by compiling the inner block,
beginning with the second <span class="code">PM_CALL_NODE</span> shown at right
in Figure 2-13.  Figure 2-17 shows what the AST for that inner block looks like.</p>
<div style="padding: 8px 30px 30px 0px; text-align: center; line-height:18px">
<img width="100%" src="https://patshaughnessy.net/assets/2025/11/3/Figure-2-17.svg"><br/>
<span style="font-style: italic; font-size: small">
Figure 2-17: The branch of the AST for the contents of the block
</span>
</div>
<p>Notice Ruby inserted a scope node at the top of this branch of the AST also.
Figure 2-17 shows the scope node contains two values: <span
class="code">argc=1</span> and <span class="code">locals: [n]</span>.  These
values were empty in the parent scope node, but Ruby set them here to indicate
the presence of the block parameter <span class="code">n</span>.  From a
relatively high level, Figure 2-18 shows how Ruby compiles the inner block.</p>
<div style="padding: 8px 30px 30px 0px; text-align: center; line-height:18px">
<img width="75%" src="https://patshaughnessy.net/assets/2025/11/3/Figure-2-18.svg"><br/>
<span style="font-style: italic; font-size: small">
Figure 2-18: How Ruby compiles a call to a block
</span>
</div>
<p>You can see the parent <span class="code">PM_NODE_SCOPE</span> at the top, along
with the YARV code from Figure 2-16. And below that Figure 2-18 shows the the
inner scope node for the block, along with the YARV instructions for the block’s
call to <span class="code">puts n</span>. Later in this chapter we’ll learn how
Ruby handles parameters and local variables, like <span class="code">n</span> in
this example; why Ruby generates these instructions for <span class="code">puts
n</span>.  The key point for now is that Ruby compiles each distinct scope in
your Ruby program—methods, blocks, classes, or modules, for example—into a
separate snippet of YARV instructions.</p>
</section><section class="comments"><div id="disqus_thread"><script type="text/javascript">var disqus_identifier = 'https://patshaughnessy.net/2025/11/3/compiling-a-call-to-a-block'; var disqus_shortname = 'patshaughnessy'; var disqus_title = 'Compiling a Call to a Block';</script></div><script type="text/javascript" src="https://disqus.com/forums/patshaughnessy/embed.js"></script><noscript><a href="https://patshaughnessy.disqus.com/?url=ref">View the discussion thread.</a></noscript></section></article></div></div></div><div class="two columns"><div id="sidebar"><img src="/assets/images/pat.jpg"></img><div class="header">Subscribe</div><div class="links"><ul><li><a id="feed" href="http://feeds.feedburner.com/patshaughnessy"><img src="/assets/images/feed-icon16x16B.png"></img></a><a href="http://twitter.com/pat_shaughnessy"><img width="20" height="20" src="/assets/images/twitter.svg"></img></a></li></ul></div><div class="header">Buy My Book</div><div class="links"><ul><li><a href="/ruby-under-a-microscope"><img src="/assets/images/book-cover.png"></img></a></li><li id="eBook"><a href="/ruby-under-a-microscope">Ruby Under a Microscope</a></li></ul></div><div class="header">More on Updating Ruby Under a Microscope</div><div class="links"><ul><li><a href="/2025/11/10/yarvs-internal-stack-and-your-ruby-stack">YARV’s Internal Stack and Your Ruby Stack</a></li><li><a href="/2025/10/27/parsing-how-ruby-understands-your-code">Parsing: How Ruby Understands Your Code</a></li><li><a href="/2025/2/18/write-barriers">Write Barriers</a></li><li><a href="/2025/2/11/using-different-size-pools">Using Different Size Pools</a></li></ul></div><div class="header">Popular</div><div class="links"><ul><li><a href="/2016/11/26/learning-to-read-x86-assembly-language">Learning to Read x86 Assembly Language</a></li><li><a href="/2012/1/4/never-create-ruby-strings-longer-than-23-characters">Never create Ruby strings longer than 23 characters</a></li><li><a href="/2012/3/23/why-you-should-be-excited-about-garbage-collection-in-ruby-2-0">Why You Should Be Excited About Garbage Collection in Ruby 2.0</a></li><li><a href="/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy">Ruby 2.0 Works Hard So You Can Be Lazy</a></li></ul></div><div class="header"><a href="/">More...</a></div></div></div><script type="text/javascript">(function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());</script></div><div id="footer" class="ten columns"><p>Content and UI design &copy; 2008-2025 Pat Shaughnessy</p></div></body></html>