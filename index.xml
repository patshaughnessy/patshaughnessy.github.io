<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Pat Shaughnessy</title><id>http://patshaughnessy.net</id><updated>2025-02-05T17:54:03Z</updated><author><name>Pat Shaughnessy</name></author><entry><title>Using Different Size Pools</title><link href="https://patshaughnessy.net/2025/2/11/using-different-size-pools" rel="alternate"></link><id href="https://patshaughnessy.net/2025/2/11/using-different-size-pools" rel="alternate"></id><published>2025-02-11T00:00:00Z</published><updated>2025-02-11T00:00:00Z</updated><category>Updating Ruby Under a Microscope</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;i&gt;
&lt;p&gt;
I've started working on a new edition of &lt;a
href=&quot;http://patshaughnessy.net/ruby-under-a-microscope&quot;&gt;Ruby Under a
Microscope&lt;/a&gt; that covers Ruby 3.x. I'm working on this in my spare time, so it
will take a while. Leave a comment or &lt;a
href=&quot;mailto:pat@patshaughnessy.net?subject=Ruby Under a Microscope Update&quot;&gt;drop
me a line&lt;/a&gt; and I'll email you when it's finished.
&lt;/p&gt;
&lt;p&gt;
The Ruby team</summary><content type="html">&lt;i&gt;
&lt;p&gt;
I've started working on a new edition of &lt;a
href=&quot;http://patshaughnessy.net/ruby-under-a-microscope&quot;&gt;Ruby Under a
Microscope&lt;/a&gt; that covers Ruby 3.x. I'm working on this in my spare time, so it
will take a while. Leave a comment or &lt;a
href=&quot;mailto:pat@patshaughnessy.net?subject=Ruby Under a Microscope Update&quot;&gt;drop
me a line&lt;/a&gt; and I'll email you when it's finished.
&lt;/p&gt;
&lt;p&gt;
The Ruby team has done a tremendous amount of work over the past decade on
Ruby's garbage collection (GC) implementation. In fact, Ruby's new GC is one of
the key reasons Ruby 3 is so much faster than Ruby 2. To bring all of this work
to light, I decided to rewrite Chapter 12 from scratch, covering garbage
collection in Ruby more accurately and in more depth.  But then, after a few
months, I realized I had gotten carried away and wrote too much material for one
chapter. So the updated book will have two new chapters on garbage collection:
one on garbage collection basics and a second new chapter on incremental and
generational garbage collection. Here's a small excerpt.
&lt;/p&gt;
&lt;/i&gt;
&lt;h2&gt;Chapter 12: Garbage Collection Basics&lt;/h2&gt;
&lt;div style=&quot;font-size: small&quot;&gt;
&lt;table id=&quot;toc&quot;&gt;
	&lt;tr&gt;
		&lt;td&gt;Where Do Ruby Values Live?&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;The RVALUE Structure&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;RVALUE Written in C&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;The Free List&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Embedded Values&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Size Pools&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Experiment 12-1: Using Different Size Pools&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Cleaning Up Unused Values&lt;/td&gt;&lt;td&gt;19&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Filling Up a Page&lt;/td&gt;&lt;td&gt;19&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Marking&lt;/td&gt;&lt;td&gt;22&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Sweeping&lt;/td&gt;&lt;td&gt;24&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Ruby Frees An Object&lt;/td&gt;&lt;td&gt;28&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Experiment 12-2: When Does Ruby Collect Your Garbage?&lt;/td&gt;&lt;td&gt;29&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Summary&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div style=&quot;float: left; padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img id=&quot;microscope&quot; src=&quot;https://patshaughnessy.net/assets/2025/2/4/experiment.png&quot;&gt;&lt;br/&gt;
&lt;/div&gt;
&lt;h2&gt;Experiment 12-1: Using Different Size Pools&lt;/h2&gt;
&lt;p&gt;Ruby 3.2 and later provides a way to see statistics about size pools, the
&lt;span class=&quot;code&quot;&gt;GC.stat_heap&lt;/span&gt; class method. &lt;span
class=&quot;code&quot;&gt;GC.stat_heap&lt;/span&gt; returns a hash as shown in Listing 12-5.&lt;/p&gt;
&lt;div style=&quot;clear: left&quot;&gt;&lt;/div&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#795da3;&quot;&gt;require &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;pp&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;pp &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;GC&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.stat_heap
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;=&amp;gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  {&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;slot_size: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;40&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;   &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;heap_eden_pages: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;   &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;heap_eden_slots: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16374&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;   &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;total_allocated_pages: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;   &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;force_major_gc_count: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;   &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;force_incremental_marking_finish_count: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;   &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;total_allocated_objects: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;26378&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;   &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;total_freed_objects: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10231&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;},
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;=&amp;gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  {&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;slot_size: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Etc…&lt;/span&gt;&lt;/pre&gt;

&lt;div style=&quot;font-style: italic; font-size: small; margin: -20px 0 20px 0&quot;&gt;
  Listing 12-5: Calling GC.stat_heap
&lt;/div&gt;
&lt;p&gt;Listing 12-5 shows the output of &lt;span class=&quot;code&quot;&gt;GC.stat_heap&lt;/span&gt; for Size
Pool 0, which includes the slot size (&lt;span class=&quot;code&quot;&gt;:slot_size=&amp;gt;40&lt;/span&gt;),
the number of pages Ruby has allocated so far for this size (&lt;span
class=&quot;code&quot;&gt;:heap_eden_pages=&amp;gt;10&lt;/span&gt;) and the total number of slots
allocated across all of these pages (&lt;span
class=&quot;code&quot;&gt;:heap_eden_slots=&amp;gt;16374&lt;/span&gt;). The output of &lt;span
class=&quot;code&quot;&gt;GC.stat_heap&lt;/span&gt; continues on to show the same statistics for
the other size pools.&lt;/p&gt;
&lt;p&gt;We can use &lt;span class=&quot;code&quot;&gt;GC.stat_heap&lt;/span&gt; to investigate how Ruby uses
size pools as we allocate more and more objects. Listing 12-6 shows a Ruby
program that allocates arrays of varying sizes, and then records the output from
&lt;span class=&quot;code&quot;&gt;GC.stat_heap.&lt;/span&gt;&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) CAPACITY_ITER &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    ALLOCATE_ITER &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10000
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) all &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;CAPACITY_ITER&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.times &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;capa&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)   &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ALLOCATE_ITER&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.times &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        all &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;&amp;lt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Array.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(capa)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)   total_slots_by_size_pool &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;GC&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.stat_heap.each &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;size_pool, stats&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        total_slots_by_size_pool[size_pool] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; stats[&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;:heap_eden_slots&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      print &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{capa}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      print &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{total_slots_by_size_pool[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      print &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{total_slots_by_size_pool[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      print &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{total_slots_by_size_pool[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      print &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{total_slots_by_size_pool[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      puts  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{total_slots_by_size_pool[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;div style=&quot;font-style: italic; font-size: small; margin: -20px 0 20px 0&quot;&gt;
  Listing 12-6: Detecting Which Size Pool Ruby Uses for Arrays of Varying Sizes
&lt;/div&gt;
&lt;p&gt;This program contains an inner loop and an outer loop. The outer loop at (3) in
Listing 12-6 iterates over arrays of different capacities, from 1 up to 100
(&lt;span class=&quot;code&quot;&gt;CAPACITY_ITER&lt;/span&gt;). For each array capacity, the program
creates 10,000 (&lt;span class=&quot;code&quot;&gt;ALLOCATE_ITER&lt;/span&gt;) array objects of that
size using the inner loop (4). Note the program saves all of the new arrays into
a single array called all, created at (2). This insures that Ruby doesn’t free
all of our new arrays by running a garbage collection.&lt;/p&gt;
&lt;p&gt;After creating 10,000 arrays of the given capacity, the program saves the &lt;span
class=&quot;code&quot;&gt;heap_eden_slots&lt;/span&gt; value from the return value of &lt;span
class=&quot;code&quot;&gt;GC.stat_heap&lt;/span&gt; for all of the size pools at (5), and then
prints out the results at (6).&lt;/p&gt;
&lt;p&gt;Running the code in Listing 12-6 produces this output:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;22923&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6548&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;34385&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6548&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;44209&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6548&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6548&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;13914&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;23735&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;34374&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;44195&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54016&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2861&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;9&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54016&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;11446&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54016&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;21257&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;11&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54033&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;54016&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;31477&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;611&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;306
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Etc…&lt;/span&gt;&lt;/pre&gt;

&lt;div style=&quot;font-style: italic; font-size: small; margin: -20px 0 20px 0&quot;&gt;
  Listing 12-7: The Output From Running the Program in Listing 12-6
&lt;/div&gt;
&lt;p&gt;The output in Listing 12-7 shows how many slots Ruby has allocated in total
after each iteration of the outer, array capacity loop. For example:&lt;/p&gt;
&lt;pre&gt;0, 22923, 6548, 2861, 611, 306&lt;/pre&gt;
&lt;p&gt;… shows that after allocating 10,000 empty arrays, Ruby has now uses a total of
22923 slots for Size Pool 0, 6548 for Size Pool One, 2861 for Size Pool Two,
etc. If you try running this, you will see slightly different values.&lt;/p&gt;
&lt;p&gt;Plotting these values, we can see which pool Ruby uses for the new arrays of
various capacities:&lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img src=&quot;http://localhost/assets/2025/2/11/Figure-12-10.svg&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Figure 12-10: Allocating Slots for Arrays of Various Sizes - Size Pools 0, 1 and 2.
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Each bar in Figure 12-10 represents values from a line of output from Listing
12-7. For example, the first bar on the far left plots this output:&lt;/p&gt;
&lt;pre&gt;0, 22923, 6548, 2861, 611, 306&lt;/pre&gt;
&lt;p&gt;The first value, 0, is the position of each bar on the x-axis, while the bar’s
color segments display the following three values: The dark grey bar at the
bottom left corner represents Size Pool 0 (22923), the lighter bar above it
shows Size Pool 1 (6548), and the lightest, top bar shows Size Pool 2 (286118).&lt;/p&gt;
&lt;p&gt;Moving to the right, each successive bar shows the values for different array
capacities. Looking over the entire graph, we can see the following pattern in
Figure 12-10:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The dark grey bars for Size Pool 0 at the bottom of Figure 12-10 increase in
size from capacity 0 through capacity 3, and then remain the same height after
that for capacities 4 and greater.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The medium grey bars for Size Pool 1 have the same height from capacity 0
through 3, but then increase from capacity 4 through 8. From capacity 9 and
onward, the medium grey bars have the same height again.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The light grey bars at the top for Size Pool 2 remain small for capacities 0
through 8, and then increase in size steadily for capacities 9 through 18. Then
the remain unchanged after that.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Figure 12-10 shows Ruby saves new arrays using the following size pools:&lt;/p&gt;
&lt;pre&gt;Capacity Range	Size Pool
0-3			0
4-8			1
9-18			2&lt;/pre&gt;
&lt;p&gt;Plotting the entire output from Listing 12-7 up to capacity=100, we see the
following:&lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img src=&quot;http://localhost/assets/2025/2/11/Figure-12-11.svg&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Figure 12-11: Complete Output from Listing 12-7
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Figure 12-11 shows an interesting pattern. Ruby uses size pools 0 through 4 to
save arrays with capacities from 0 up to 78 in a similar way:&lt;/p&gt;
&lt;pre&gt;Capacity Range	Size Pool
0-3			0
4-8			1
9-18			2
19-38			3
39-78			4&lt;/pre&gt;
&lt;p&gt;For each capacity range, the length of the corresponding bars grows steadily,
and then stops growing.&lt;/p&gt;
&lt;p&gt;However, once we started to save large arrays with capacities of 79 or more
elements, Ruby saved them in the original Size Pool Zero again. This indicates
that Ruby stopped embedding the array elements in the size pool entirely, and
instead allocated a new, separate memory segment to save the elements. For these
large arrays, small 40 byte RVALUE slots in Size Pool Zero were sufficient,
because they each contained a pointer to the array data, and not the embedded
array data itself.&lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img src=&quot;http://localhost/assets/2025/2/11/Figure-12-12.svg&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Figure 12-12: A Large Array Saving Its Elements In A Separate Memory Segment
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Figure 12-12 shows how large arrays, arrays which contain 79 or more elements,
do not save their elements inside of the RVALUE structure, but instead save a
pointer (ptr) which contains the location of a separate memory segment that
holds the array elements.&lt;/p&gt;
&lt;p&gt;One key detail of this experiment was in Listing 12-6 at (2): the all array. The
inner loop just below in Listing 12-6 at (4) saved each new array into the all
array. This meant all the new arrays were in fact still being used and Ruby’s
garbage collector could not reclaim their memory. Without this line of code, we
would not have seen the total number of slots continually increase, preventing
us from discovering which slots Ruby saved the arrays into.&lt;/p&gt;
&lt;p&gt;But how did Ruby’s garbage collector know this, exactly? How does Ruby identify
which values are used and unused by our programs? And how does it reclaim memory
from the unused values? Let’s take a look at Ruby’s garbage collection process
next.&lt;/p&gt;
</content></entry><entry><title>Inserting One New Element into Hashes of Varying Sizes</title><link href="https://patshaughnessy.net/2025/2/4/inserting-one-new-element-into-hashes-of-varying-sizes" rel="alternate"></link><id href="https://patshaughnessy.net/2025/2/4/inserting-one-new-element-into-hashes-of-varying-sizes" rel="alternate"></id><published>2025-02-04T00:00:00Z</published><updated>2025-02-04T00:00:00Z</updated><category>Updating Ruby Under a Microscope</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;i&gt;
&lt;p&gt;
I've started working on a new edition of &lt;a
href=&quot;http://patshaughnessy.net/ruby-under-a-microscope&quot;&gt;Ruby Under a
Microscope&lt;/a&gt; that covers Ruby 3.x. I'm working on this in my spare time, so it
will take a while. Leave a comment or &lt;a
href=&quot;mailto:pat@patshaughnessy.net?subject=Ruby Under a Microscope Update&quot;&gt;drop
me a line&lt;/a&gt; and I'll email you when it's finished.
&lt;/p&gt;
&lt;p&gt;
&lt;p&gt;RUM includ</summary><content type="html">&lt;i&gt;
&lt;p&gt;
I've started working on a new edition of &lt;a
href=&quot;http://patshaughnessy.net/ruby-under-a-microscope&quot;&gt;Ruby Under a
Microscope&lt;/a&gt; that covers Ruby 3.x. I'm working on this in my spare time, so it
will take a while. Leave a comment or &lt;a
href=&quot;mailto:pat@patshaughnessy.net?subject=Ruby Under a Microscope Update&quot;&gt;drop
me a line&lt;/a&gt; and I'll email you when it's finished.
&lt;/p&gt;
&lt;p&gt;
&lt;p&gt;RUM includes a series of “experiments:” simple code snippets that show evidence the book’s explanations are accurate. One of the first experiments I wrote back in 2013, Experiment 7-2 is a fun way to see exactly when Ruby increases the number of bins in a hash table. The experiments in RUM are a great way to see for yourself how Ruby works. They also keep me honest; in fact, I ran this code again recently using Ruby 3.4.1 and saw different results than what I expected!&lt;/p&gt;
&lt;/p&gt;
&lt;/i&gt;
&lt;h2&gt;Chapter 7: The Hash Table: The Workhorse Of Ruby Internals&lt;/h2&gt;
&lt;div style=&quot;font-size: small&quot;&gt;
&lt;table id=&quot;toc&quot;&gt;
	&lt;tr&gt;
		&lt;td&gt;Hash Tables in Ruby&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Saving a Value in a Hash Table&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Retrieving a Value from a Hash Table&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Hash Tables Expand to Accommodate More Values&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Hash Collisions and Open Addressing&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Searching For an Element Using Open Addressing&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Expanding a Hash Table&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Does Ruby Decide How Many Entries And Bins To Use?&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes&lt;/td&gt;&lt;td&gt;17&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Optimization for Small Hashes&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Does Ruby Convert A Packed Hash Into A Hash Table?&lt;/td&gt;&lt;td&gt;22&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Ruby Implements Hash Functions&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Experiment 7-3: Using Objects as Keys in a Hash&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Summary&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div style=&quot;float: left; padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img id=&quot;microscope&quot; src=&quot;https://patshaughnessy.net/assets/2025/2/4/experiment.png&quot;&gt;&lt;br/&gt;
&lt;/div&gt;
&lt;h2&gt;Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes&lt;/h2&gt;
&lt;p&gt;One way to test whether this rehashing, or redistribution, of entries really
occurs when Ruby expands a hash is to measure the amount of time Ruby takes to
save one new element into existing hashes of different sizes. As we add more
elements to the same hash, we should eventually see evidence that Ruby is taking
extra time to rehash the elements. &lt;/p&gt;
&lt;div style=&quot;clear: left&quot;&gt;&lt;/div&gt;
&lt;p&gt;The code for this experiment is shown in Listing 7-3.&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#795da3;&quot;&gt;require &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;benchmark&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.times &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;size&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    hashes &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10000&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.times &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      hash &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      (&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;..&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;size).each &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        hash[rand] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;rand
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end 
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      hashes &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;&amp;lt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;hash
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end 
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;GC&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.disable
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Benchmark&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.bm &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;bench&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      bench.report(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;adding element number &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{size&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10000&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.times &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;n&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;| 
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)       hashes[n][size] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;rand
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end 
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end 
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end 
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;GC&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.enable
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;div style=&quot;font-style: italic; margin: 0 0 20px 0&quot;&gt;
  Listing 7-3: Adding one more element to hashes of different sizes  
&lt;/div&gt;
&lt;p&gt;At (1) the outer loop iterates over hash sizes from 0 to 100, and at (2) the
inner loop creates 10,000 hashes of the given size. After disabling garbage
collection, this experiment uses the benchmark library to measure how long it
takes Ruby to insert a single new value at (3) into all 10,000 hashes of the given
size. The results are surprising! Figure 7-13 shows the results for Ruby 3.4.1. &lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img width=&quot;100%&quot; src=&quot;https://patshaughnessy.net/assets/2025/2/4/Figure-7-3.svg&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Figure 7-13: Time to add 10,000 key/value pairs vs. hash size (Ruby 3.4.1) 
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Interpreting these data values from left to right, we see the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;It takes about 0.6 ms to insert the first element into an empty hash (10,000
times). &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As the hash size increases from 2 to 8, the amount of time required to insert
a new element is about the same: 0.6ms more or less.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inserting the 9th key/value pair takes much longer, about 2ms for 10,000
hashes! &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next, as the hash size increases from 10 up to 16, once again Ruby can insert
new elements quickly, between 0.6ms and 0.7ms (10,000 times).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A huge spike! It takes almost 3.1ms to insert the 17th element.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;And then once again starting with the 18th element, the time to insert each
element reduced to around 0.7ms-0.8.ms.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A 3rd spike appears when Ruby inserts the 33rd element: almost 5ms.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The graph once again flattens and returns to around 0.7-0.8ms per element (10,000
times).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;And a 4th spike appears when Ruby inserts the 65th element: almost 6ms.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What’s going on here? Well, Ruby spends the extra time required to insert that
17th key/value pair expanding the hash table: reallocating the entries array from
16 to 32 entries, and the bin array from 32 to 64 bins, and then reassigning
the &lt;code&gt;st_table_entry&lt;/code&gt; structures to the new bin array. Ruby expands the entries and
bins arrays a second time again after inserting the 33rd entry, this from from 32
to 64 entries and 64 to 128 bins. (Recall the &lt;code&gt;st_features&lt;/code&gt; table, shown on page
15, used powers of 2 to determine these array sizes.)&lt;/p&gt;
&lt;p&gt;The smaller spike on the 9th insert in this figure is curious.  While not as
pronounced as the spike at the 17th element, this smaller spike is nonetheless
noticeable. As it turns out, Ruby contains another optimization that speeds up
hash access even more for small hashes that contain less than 9 elements.&lt;/p&gt;
</content></entry><entry><title>Updating Ruby Under a Microscope</title><link href="https://patshaughnessy.net/2025/1/28/updating-ruby-under-a-microscope" rel="alternate"></link><id href="https://patshaughnessy.net/2025/1/28/updating-ruby-under-a-microscope" rel="alternate"></id><published>2025-01-28T00:00:00Z</published><updated>2025-01-28T00:00:00Z</updated><category>Updating Ruby Under a Microscope</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img id=&quot;microscope&quot; src=&quot;https://patshaughnessy.net/assets/2014/12/17/microscope.png&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Ruby stores much of its own internal data in hash tables.
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;I've started working on a new edition of &lt;a
href=&quot;http://patshaughnessy.net/ruby-unde</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img id=&quot;microscope&quot; src=&quot;https://patshaughnessy.net/assets/2014/12/17/microscope.png&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Ruby stores much of its own internal data in hash tables.
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;I've started working on a new edition of &lt;a
href=&quot;http://patshaughnessy.net/ruby-under-a-microscope&quot;&gt;Ruby Under a
Microscope&lt;/a&gt; that covers Ruby 3.x. I'm working on this in my spare time, so it
will take a while to finish. Leave a comment or &lt;a
href=&quot;mailto:pat@patshaughnessy.net?subject=Ruby Under a Microscope Update&quot;&gt;drop
me a line&lt;/a&gt; and I'll email you when it's finished.&lt;/p&gt;
&lt;p&gt;In the meantime, here’s an excerpt from a rewrite of Chapter 7 about hash
tables. Vladimir Makarov and the Ruby team redesigned Ruby’s hash table
implementation back in 2015 to use open addressing, shortly after I published
the first edition of RUM.  This seemed like a good place to start.&lt;/p&gt;
&lt;div style=&quot;clear: left&quot;&gt;&lt;/div&gt;
&lt;h2&gt;Chapter 7: The Hash Table: The Workhorse Of Ruby Internals&lt;/h2&gt;
&lt;div style=&quot;font-size: small&quot;&gt;
&lt;table id=&quot;toc&quot;&gt;
	&lt;tr&gt;
		&lt;td&gt;Hash Tables in Ruby&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Saving a Value in a Hash Table&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Retrieving a Value from a Hash Table&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Hash Tables Expand to Accommodate More Values&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Hash Collisions and Open Addressing&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Searching For an Element Using Open Addressing&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Expanding a Hash Table&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Does Ruby Decide How Many Entries And Bins To Use?&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes&lt;/td&gt;&lt;td&gt;17&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Optimization for Small Hashes&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Does Ruby Convert A Packed Hash Into A Hash Table?&lt;/td&gt;&lt;td&gt;22&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;How Ruby Implements Hash Functions&lt;/td&gt;&lt;td&gt;23&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Experiment 7-3: Using Objects as Keys in a Hash&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Summary&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2&gt;Hash Tables in Ruby&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Hash tables&lt;/em&gt; are a commonly used, well-known, age-old concept in computer
science. They organize values into groups, or &lt;em&gt;bins&lt;/em&gt;, based on an integer value
calculated from each value — a &lt;em&gt;hash&lt;/em&gt;. When you need to find a value, you can
figure out which bin it’s in by recalculating its hash value, thus speeding up
the search. &lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2025/1/28/bins.png&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Every time you write a method, Ruby creates an entry in a hash table. 
&lt;/span&gt;
&lt;/div&gt;
&lt;div style=&quot;clear: right&quot;&gt;&lt;/div&gt;
&lt;h2&gt;Saving a Value in a Hash Table&lt;/h2&gt;
&lt;p&gt;Figure 7-1 shows a single hash object and its hash table.&lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img width=&quot;100%&quot; src=&quot;https://patshaughnessy.net/assets/2025/1/28/Figure-7-1.svg&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Figure 7-1: A Ruby hash object with an empty hash table 
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;On the left is the &lt;code&gt;RHash&lt;/code&gt; (short for &lt;em&gt;Ruby hash&lt;/em&gt;) structure. On the right, you see
the hash table used by this hash, represented by the &lt;code&gt;st_table&lt;/code&gt; structure. This C
structure contains the basic information about the hash table, including the
number of entries saved in the table and pointers to the entries and bins. Each
&lt;code&gt;RHash&lt;/code&gt; structure contains a pointer to a corresponding &lt;code&gt;st_table&lt;/code&gt; structure. For
many hashes, Ruby initially creates 32 entries and 64 bins. (Hashes with 8 or
fewer entries work somewhat differently; see “Optimization for Small Hashes” on
page 20.) The best way to understand how a hash table works is by stepping
through an example. Suppose I add a new key/value to a hash called &lt;code&gt;my_hash&lt;/code&gt;: &lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;my_hash[&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;:key&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;value&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;While executing this line of code, Ruby saves the key and value into the first
entry, as shown in Figure 7-2.&lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img width=&quot;100%&quot; src=&quot;https://patshaughnessy.net/assets/2025/1/28/Figure-7-2.svg&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Figure 7-2: A Ruby hash object containing a single value
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Here you can see the new key/value pair inside the first entry slot, called an
&lt;code&gt;st_table_entry&lt;/code&gt; in Ruby’s C source code. Ruby saves the keys and values in the
entries array in the order you add them. This makes it easy for Ruby to return
them back to you in the same order. Also see that Ruby saved an entry index of 0
in the third bin, number 2. Ruby did this by taking the given key — in this
example, the symbol &lt;code&gt;:key&lt;/code&gt; — and passing it to an internal hash function that
returns a pseudorandom integer: &lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;some_value &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; internal_hash_function(&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;:key&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Next, Ruby takes the hash value — in this example, &lt;code&gt;some_value&lt;/code&gt; — and calculates the modulus by the number of bins, which is the remainder after dividing by the number of bins.&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;some_value &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;% &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;/pre&gt;

&lt;div style=&quot;margin-bottom: 2.5rem; font-style: italic&quot;&gt;
NOTE: In Figure 7-2, I assume that the actual hash value for &lt;span
class=&quot;code&quot;&gt;:key&lt;/span&gt; divided by 64 leaves a remainder of 2. Later in this
chapter, I’ll explore in more detail the hash functions that Ruby actually uses.
We’ll see how using 64 bins (a power of 2) speeds up this calculation.  &lt;/div&gt;
&lt;p&gt;Now let’s add a second element to the hash:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;my_hash[&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;:key2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;value2&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This time let’s imagine that the hash value of &lt;code&gt;:key2&lt;/code&gt; divided by 64 yields a
remainder of 5. &lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;internal_hash_function(&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;:key2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;% &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;64 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Figure 7-3 shows that Ruby fills in a second &lt;code&gt;st_table_entry&lt;/code&gt; structure in the
entries array, and the entry index 1 in bin number 5, the sixth bin.&lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img width=&quot;100%&quot; src=&quot;https://patshaughnessy.net/assets/2025/1/28/Figure-7-3.svg&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Figure 7-3: A Ruby hash object containing two values
&lt;/span&gt;
&lt;/div&gt;
&lt;h2&gt;Retrieving a Value from a Hash Table&lt;/h2&gt;
&lt;p&gt;The benefit of using a hash table becomes clear when you ask Ruby to retrieve
the value for a given key. For example: &lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;p my_hash[&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;:key&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; =&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;value&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;If Ruby had saved all of the keys and values in an array or linked list, it
would have to iterate over all the elements in that array or list, looking for
:key. This might take a very long time, depending on the number of elements. But
using a hash table, Ruby can jump straight to the key it needs to find by
recalculating the hash value for that key.  To recalculate the hash value for a
particular key, Ruby simply calls the hash function again: &lt;code&gt;some_value = internal_hash_function(:key)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then, it redivides the hash value by the number of bins to get the remainder, or
the modulus. &lt;code&gt;some_value % 64 = 2&lt;/code&gt; At this point, Ruby knows to look in bin
number 2 and finds the entry index 0, and in turn finds the entry with the key
of &lt;code&gt;:key&lt;/code&gt; in entry number 0 or the first entry slot.  Ruby can later find the
value for &lt;code&gt;:key2&lt;/code&gt; by repeating the same hash calculation
&lt;code&gt;internal_hash_function(:key2) % 64 = 5&lt;/code&gt;.&lt;/p&gt;
&lt;div style=&quot;padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
&lt;img width=&quot;100%&quot; src=&quot;https://patshaughnessy.net/assets/2025/1/28/Figure-7-4.svg&quot;&gt;&lt;br/&gt;
&lt;span style=&quot;font-style: italic; font-size: small&quot;&gt;
  Figure 7-4: Finding Values in a Hash Table
&lt;/span&gt;
&lt;/div&gt;
&lt;p&gt;Figure 7-4 explains how Ruby would find these two values in the hash table: On
the left side, the first arrow starts from the third bin (bin index 2 =
&lt;code&gt;internal_hash_function(:key) % 64&lt;/code&gt;) and points to the first key/value pair, at
index 0. To the right, the second arrow starts from the sixth bin (bin index 5 =
&lt;code&gt;internal_hash_function(:key2) % 64&lt;/code&gt;) and points to the second key/value pair, at
index 1.&lt;/p&gt;
&lt;span style=&quot;font-style: italic&quot;&gt;
NOTE: The C library used by Ruby to implement hash tables was written in the
1980s by Peter Moore from the University of California, Berkeley. Later in 2015
Vladimir Makarov rewrote the hash table code, using a data structure which saves
the entry and bin arrays in contiguous memory segments. By saving all the
entries and bins nearby each other in memory, modern CPUs are able to cache all
of the data in the hash table more efficiently, speeding up the overall process.
You can find Makarov’s hash table code in the C code files st.c and
include/ruby/st.h. All of the function and structure names in that code use the
naming convention st_. The definition of the RHash structure that represents
every Ruby Hash object is in the include/ruby/ruby.h file. Along with RHash,
this file contains all of the other primary object structures used in the Ruby
source code: RString, RArray, RValue, and so on. 
&lt;/span&gt;
</content></entry><entry><title>LLVM IR: The Esperanto of Computer Languages</title><link href="https://patshaughnessy.net/2022/2/19/llvm-ir-the-esperanto-of-computer-languages" rel="alternate"></link><id href="https://patshaughnessy.net/2022/2/19/llvm-ir-the-esperanto-of-computer-languages" rel="alternate"></id><published>2022-02-19T00:00:00Z</published><updated>2022-02-19T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 0px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2022/2/19/esperanto.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt; Esperanto grammar is logical and self&lt;br/&gt;
consistent, designed to be easy to learn. &lt;br/&gt;
  &lt;small&gt; &lt;a title=&quot;Renatoeo, CC BY-SA 4.0 &amp;lt;https://creativecommons.org/licenses/by-sa/4.0&amp;gt;, via Wikimedia Commons&quot; href=&quot;https:/</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 0px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2022/2/19/esperanto.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt; Esperanto grammar is logical and self&lt;br/&gt;
consistent, designed to be easy to learn. &lt;br/&gt;
  &lt;small&gt; &lt;a title=&quot;Renatoeo, CC BY-SA 4.0 &amp;lt;https://creativecommons.org/licenses/by-sa/4.0&amp;gt;, via Wikimedia Commons&quot; href=&quot;https://commons.wikimedia.org/wiki/File:CARD_GRAM%C3%81TICA_ESPERANTO.png&quot;&gt;via Wikimedia Commons&lt;/a&gt;&lt;/small&gt; &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;I empathize for people who have to learn English as a foreign language. English
grammar is inconsistent, arbitrary and hard to master. English spelling is even
worse. I sometimes find myself apologizing for my language’s shortcomings. But
learning any foreign language as an adult is very difficult.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Esperanto&quot;&gt;Esperanto&lt;/a&gt;, an “artificial language,”
is different. Invented by Ludwik Zamenhof in 1873, Esperanto has a vocabulary
and grammar that are logical and consistent, designed to be easier to learn.
Zamenhof intended Esperanto to become the universal second language.&lt;/p&gt;
&lt;p&gt;Computers have to learn foreign languages too. Every time you compile and run
a program, your compiler translates your code into a foreign language: the
native machine language that runs on your target platform. Compilers should
have been called translators. And compilers struggle with the same things we
do: inconsistent grammar and vocabulary, and other peculiarities of the target
platform.&lt;/p&gt;
&lt;p&gt;Recently, however, more and more compilers translate your code to an
artificial machine language. They produce a simpler, more consistent, more
powerful machine language that doesn’t actually run on any machine. This
artificial machine language, LLVM IR, makes writing compilers simpler and
reading the code compilers produce simpler too.&lt;/p&gt;
&lt;p&gt;LLVM IR is becoming the universal second language for compilers.&lt;/p&gt;
&lt;h2&gt;One Line of LLVM IR&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://llvm.org&quot;&gt;Low Level Virtual Machine&lt;/a&gt; (LLVM) project had the novel
idea of inventing a virtual machine that was easy for compiler engineers to use
as a target platform. The LLVM team designed a special instruction set called
&lt;a href=&quot;https://llvm.org/docs/LangRef.html&quot;&gt;intermediate representation&lt;/a&gt; (IR). New,
modern languages such as Rust, Swift, Clang-based versions of C and many
others, first translate your code to LLVM IR. Then they use the LLVM framework
to convert the IR into actual machine language for any target platform LLVM
supports:&lt;/p&gt;
&lt;img style=&quot;width: 500px; margin-bottom: 20px&quot; src=&quot;https://patshaughnessy.net/assets/2022/2/19/platforms.svg&quot;&gt;
&lt;p&gt;LLVM is great for compilers. Compiler engineers don’t have to worry about the
detailed instruction set of each platform, and LLVM optimizes your code for
whatever platform you choose automatically. And LLVM is also great for people
like me who are interested in what machine language instructions look like and
how CPUs execute them. LLVM instructions are much easier to follow than real
machine instructions. Let’s take a look at one!&lt;/p&gt;
&lt;p&gt;Here’s a line of LLVM IR I generated from a simple
&lt;a href=&quot;https://crystal-lang.org&quot;&gt;Crystal&lt;/a&gt; program:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;%57 = call %&quot;Array(Int32)&quot;* @&quot;*Array(Int32)@Array(T)::unsafe_build&lt;Int32&gt;:Array(Int32)&quot;(i32 610, i32 2), !dbg !89&lt;/pre&gt;
&lt;p&gt;Wait a minute! This isn’t simple or easy to follow at all! What am I talking
about here? At first glance, this does look confusing. But as we’ll see, most
of the confusing syntax is related to Crystal, not LLVM. Studying this line of
code will reveal more about Crystal than it will about LLVM.&lt;/p&gt;
&lt;p&gt;The rest of this article will unpack and explain what this line of code means.
It looks complex, but is actually quite simple.&lt;/p&gt;
&lt;h2&gt;The Call Instruction&lt;/h2&gt;
&lt;p&gt;The instruction above is a function call in LLVM IR. To produce this code, I
wrote a small Crystal program and then translated it using this command:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;$ crystal build array_example.cr --emit llvm-ir&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;--emit&lt;/code&gt; option directed Crystal to generate a file called array_example.ll,
which contains the line above along with thousands of other lines. We’ll get to
the Crystal code in a minute. But for now, how do I get started understanding
what the LLVM code means?&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://llvm.org/docs/LangRef.html&quot;&gt;LLVM Language Reference Manual&lt;/a&gt; has
documentation for &lt;code&gt;call&lt;/code&gt; and all of the other LLVM IR instructions. Here’s the
syntax for &lt;code&gt;call&lt;/code&gt;:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;&amp;lt;result&gt; = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(&amp;lt;num&gt;)]
         &amp;lt;ty&gt;|&amp;lt;fnty&gt; &amp;lt;fnptrval&gt;(&amp;lt;function args&gt;) [fn attrs] [ operand bundles ]&lt;/pre&gt;
&lt;p&gt;My example &lt;code&gt;call&lt;/code&gt; instruction doesn’t use many of these options. Removing the
unused options, I can see the actual, basic syntax of &lt;code&gt;call&lt;/code&gt;:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;&amp;lt;result&gt; = call &amp;lt;ty&gt; &amp;lt;fnptrval&gt;(&amp;lt;function args&gt;)&lt;/pre&gt;
&lt;p&gt;In order from left to right, these values are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;result&amp;gt;&lt;/code&gt; which register to save the result in&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;ty&amp;gt;&lt;/code&gt; the type of the return value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;fnptrval&amp;gt;&lt;/code&gt; a pointer to the function to call&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;function args&amp;gt;&lt;/code&gt; the arguments to pass to that function&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What does all of this mean, exactly? Let’s find out!&lt;/p&gt;
&lt;h2&gt;A CPU With Infinite Registers&lt;/h2&gt;
&lt;p&gt;Starting on the left and moving right, let’s step through the &lt;code&gt;call&lt;/code&gt; instruction:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2022/2/19/result.svg&quot;&gt;
&lt;p&gt;The token &lt;code&gt;%57&lt;/code&gt; to the left of the equals sign tells LLVM where to save the
return value of the function call that follows. This isn’t a normal variable;
&lt;code&gt;%57&lt;/code&gt; is an LLVM “register.”&lt;/p&gt;
&lt;p&gt;Registers are physical circuits located on microprocessor chips used to save
intermediate values. Saving a value in a CPU register is much faster than
saving a value in memory, since the register is located on the same chip as the
rest of the microprocessor. Saving a value in RAM memory, on the other hand,
requires transmitting that value from one chip to another and is much slower,
relatively speaking. Unfortunately, each CPU has a limited number of registers
available, and so compilers have to decide which values are used frequently
enough to warrant saving in nearby registers, and which other values can be
moved out to more distant memory.&lt;/p&gt;
&lt;p&gt;Unlike the limited number of registers available on a real CPU, the imaginary
LLVM microprocessor has an infinite number of them. Because of this, compilers
that target LLVM can simply save values to a register whenever they would like.
There’s no need to find an available register, or to move an existing value out
of a register first before using it for something else. Busy work that normal
machine language code can’t avoid.&lt;/p&gt;
&lt;p&gt;In this program, the Crystal compiler had already saved 56 other values in
“registers” and so for this line of LLVM IR, Crystal simply used the next
register, number 57.&lt;/p&gt;
&lt;h2&gt;LLVM Structure Types&lt;/h2&gt;
&lt;p&gt;Moving left to right, LLVM &lt;code&gt;call&lt;/code&gt; instructions next indicate the type of the
function call’s return value:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2022/2/19/type.svg&quot;&gt;
&lt;p&gt;This name of this type, &lt;code&gt;Array(Int32)&lt;/code&gt;, is generated by the Crystal compiler, not
by LLVM. That is, this is a type from my Crystal program. It could have been
anything, and indeed other compilers that target LLVM will generate completely
different type names.&lt;/p&gt;
&lt;p&gt;The example Crystal program I used to generate this LLVM code was:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;When I compiled this program, Crystal generated the &lt;code&gt;call&lt;/code&gt; instruction above,
which returns a pointer to the new array, &lt;code&gt;arr&lt;/code&gt;. Since &lt;code&gt;arr&lt;/code&gt; is an array
containing integers, Crystal uses a generic type &lt;code&gt;Array(Int32).&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Machine languages that target real machines only support hardware types that
machine supports.  For example, Intel x86 assembly language allows you to save
integers of different widths, 16, 32 or 64 bits for example, and an Intel x86
CPU has registers designed to hold values of each of these sizes.&lt;/p&gt;
&lt;p&gt;LLVM IR is more powerful. It supports “structure types,” similar to a C
structure or an object in a language like Crystal or Swift. Here the &lt;code&gt;%&amp;quot;…&amp;quot;&lt;/code&gt;
syntax indicates the name inside the quotes is the name of a structure type.
And the asterisk which follows, like in C, indicates the type of the return
value of my function call is a pointer to this structure.&lt;/p&gt;
&lt;p&gt;My example LLVM program defines the type &lt;code&gt;Array(Int32)&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;%&quot;Array(Int32)&quot; = type { i32, i32, i32, i32, i32* }&lt;/pre&gt;
&lt;p&gt;Structure types allow LLVM IR programs to create pointers to structures or
objects, and to access any of the values inside each object. That makes writing
a compiler much easier. In my example, the call instruction returns a pointer
to an object which contains 4 32-bit integer values, followed by a pointer to
other 32 integer values. But what are all of these integer values? Above I said
this function call was returning a new array - how can that be the case?&lt;/p&gt;
&lt;p&gt;LLVM itself has no idea, and no opinion on the matter. To understand what these
values are, and what they have to do with the array in my program, we need to
learn more about the Crystal compiler that generated this LLVM IR code.&lt;/p&gt;
&lt;p&gt;Reading the &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr#L48&quot;&gt;Crystal standard
library&lt;/a&gt;,
we can see Crystal implements arrays like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)
&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;include &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Indexable&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;::Mutable(T)
&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;include &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Comparable(Array)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Size of an Array that we consider small to do linear scans or other optimizations.
&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;private &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SMALL_ARRAY_SIZE &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16 
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The size of this array.
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The capacity of `@buffer`.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Note that, because `@buffer` moves on shift, the actual
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# capacity (the allocated memory) starts at `@buffer - @offset_to_buffer`.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The actual capacity is also given by the `remaining_capacity` internal method.
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;capacity &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Offset to the buffer that was originally allocated, and which needs to
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# be reallocated on resize. On shift this value gets increased, together with
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# `@buffer`. To reach the root buffer you have to do `@buffer - @offset_to_buffer`,
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# and this is also provided by the `root_buffer` internal method.
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;offset_to_buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The buffer where elements start.
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Pointer(T)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# In 64 bits the Array is composed then by:
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# - type_id            : Int32   # 4 bytes -|
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# - size               : Int32   # 4 bytes  |- packed as 8 bytes
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# - capacity           : Int32   # 4 bytes -|
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# - offset_to_buffer   : Int32   # 4 bytes  |- packed as 8 bytes
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# - buffer             : Pointer # 8 bytes  |- another 8 bytes&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The comments above are very illustrative and complete - the Crystal team took
the time to document their standard library and explain not only how to use
each class, like &lt;code&gt;Array(T)&lt;/code&gt;, but how they are implemented internally.&lt;/p&gt;
&lt;p&gt;In this case, we can see the four &lt;code&gt;i32&lt;/code&gt; values inside the &lt;code&gt;Array(Int32)&lt;/code&gt; LLVM
structure type hold the size and capacity off the array, among other things.
And the &lt;code&gt;i32*&lt;/code&gt; value is a pointer to the actual contents of the array.&lt;/p&gt;
&lt;h2&gt;Functions&lt;/h2&gt;
&lt;p&gt;The target of the call instruction appears next, after the return type:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2022/2/19/function.svg&quot;&gt;
&lt;p&gt;This is quite a mouthful! What sort of function is this?&lt;/p&gt;
&lt;p&gt;There are two steps to understanding this: First, the &lt;code&gt;@&amp;quot;…&amp;quot;&lt;/code&gt; syntax. This is
simply a global identifier in this LLVM program. So my &lt;code&gt;call&lt;/code&gt; instruction is just
calling a global function. In LLVM programs, all functions are global; there is
no concept of a class, module or similar groupings of code.&lt;/p&gt;
&lt;p&gt;But what in the world does that crazy identifier mean?&lt;/p&gt;
&lt;p&gt;LLVM ignores this complex name. For LLVM this is just a name like &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt;.
But for Crystal, the name has much more significance. Crystal encoded a lot of
information into this one name. Crystal can do this because the LLVM code isn’t
intended for anyone to read directly. Crystal has created a “mangled name,”
meaning the original version of the function to call is there but it’s been
mangled or rewritten in a confusing manner.&lt;/p&gt;
&lt;p&gt;Crystal rewrites function names to ensure they are unique. In Crystal, like in
many other statically typed languages, functions with different argument types
or return value types are actually different functions. So in Crystal if I
write:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;foo&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(a : Int32)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Int: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{a}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;foo&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(a : String)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;String: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{a}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;foo(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;123&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#=&amp;gt; Int: 123
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;foo(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;123&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#=&amp;gt; String: 123&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;…I have two separate, different functions both called &lt;code&gt;foo&lt;/code&gt;. The type of the
parameter &lt;code&gt;a&lt;/code&gt; distinguishes one from the other.&lt;/p&gt;
&lt;p&gt;Crystal generates unique function names by encoding the arguments, return value
and type of the receiver into the into the function name string, making it
quite complex. Let’s break it down:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2022/2/19/mangled.svg&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Array(Int32)@Array(T)&lt;/code&gt; - this is the type of the receiver. That means the
&lt;code&gt;unsafe_build&lt;/code&gt; function is actually a method on the &lt;code&gt;Array(T)&lt;/code&gt; generic class.
And in this case, the receiver is an array holding 32 bit integers, the
&lt;code&gt;Array(Int32)&lt;/code&gt; class. Crystal includes both names in the mangled function name.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unsafe_build&lt;/code&gt; - this is the function Crystal is calling.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Int32&lt;/code&gt; - these are the function’s parameter types. In this case, Crystal is
passing in a single integer, so we just see one &lt;code&gt;Int32&lt;/code&gt; type.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Array(Int32)&lt;/code&gt; - this is the return value type, a new array containing integers.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As I discussed in &lt;a href=&quot;https://patshaughnessy.net/2022/1/22/visiting-an-abstract-syntax-tree&quot;&gt;my last
post&lt;/a&gt;,
the Crystal compiler internally rewrites my array literal expression &lt;code&gt;[12345, 67890]&lt;/code&gt; into code that creates and initializes a new array object:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;__temp_621 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;::Array(typeof(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)).unsafe_build(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;__temp_622 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; __temp_621.to_unsafe
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;__temp_622[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;__temp_622[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;__temp_621&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;In this expanded code, Crystal calls &lt;code&gt;unsafe_build&lt;/code&gt; and passes in &lt;code&gt;2&lt;/code&gt;, the
required capacity of the new array. And to distinguish this use of
&lt;code&gt;unsafe_build&lt;/code&gt; from other &lt;code&gt;unsafe_build&lt;/code&gt; functions that might exist in my
program, the compiler generated the mangled name we see above. &lt;/p&gt;
&lt;h2&gt;Arguments&lt;/h2&gt;
&lt;p&gt;Finally, after the function name the LLVM IR instruction shows the arguments
for the function call:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2022/2/19/args.svg&quot;&gt;
&lt;p&gt;LLVM IR uses parentheses, like most languages, to enclose the arguments to a
function call. And the types precede each value: &lt;code&gt;610&lt;/code&gt; is a 32-bit integer and
&lt;code&gt;2&lt;/code&gt; is also a 32-bit integer.&lt;/p&gt;
&lt;p&gt;But wait a minute! We saw just above the expanded Crystal code for generating
the array literal passes a single value, &lt;code&gt;2&lt;/code&gt;, into the call to &lt;code&gt;unsafe_build&lt;/code&gt;.
And looking at the mangled function name above, we also see there is a single
&lt;code&gt;i32&lt;/code&gt; parameter to the function call.&lt;/p&gt;
&lt;p&gt;But reading the LLVM IR code we can see a second value is also passed in:
&lt;code&gt;610&lt;/code&gt;. What in the world does &lt;code&gt;610&lt;/code&gt; mean? I don’t have 610 elements in my new
array, and 610 is not one of the array elements. So what is going on here?&lt;/p&gt;
&lt;p&gt;Crystal is an object oriented language, meaning that each function is
optionally associated with a class. In OOP parlance, we say that we are
“sending a message” to a “receiver.” In this case, &lt;code&gt;unsafe_build&lt;/code&gt; is the message,
and &lt;code&gt;::Array(typeof(12345, 67890))&lt;/code&gt; is the receiver. In fact, this function is
really a class method. We are calling &lt;code&gt;unsafe_build&lt;/code&gt; on the &lt;code&gt;Array(Int32)&lt;/code&gt; class,
not on an instance of one array.&lt;/p&gt;
&lt;p&gt;Regardless, LLVM IR does’t support classes or instance methods or class
methods. In LLVM IR, we only have simple, global functions. And indeed, the
LLVM virtual machine doesn’t care what these arguments are or what they mean.
LLVM doesn’t encode the meaning or purpose of each argument; it just does what
the Crystal compiler tells it to do.&lt;/p&gt;
&lt;p&gt;But Crystal, on the other hand, has to implement object oriented behavior
somehow. Specifically, the &lt;code&gt;unsafe_build&lt;/code&gt; function needs to behave differently
depending on which class it was called for, depending on what the receiver is.
For example:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;::Array(typeof(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)).unsafe_build(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;… has to return an array of two integers. While:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;::Array(typeof(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;abc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;def&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)).unsafe_build(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;…has to return an array of two strings. How does this work in the LLVM IR code?&lt;/p&gt;
&lt;p&gt;To implement object oriented behavior, Crystal passes the receiver as a hidden,
special argument to the function call:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2022/2/19/args2.svg&quot;&gt;
&lt;p&gt;This receiver argument is a reference or pointer to the receiver’s object, and
is normally known as &lt;code&gt;self&lt;/code&gt;. Here &lt;code&gt;610&lt;/code&gt; is a reference or tag corresponding to
the &lt;code&gt;Array(Int32)&lt;/code&gt; class, the receiver. And &lt;code&gt;2&lt;/code&gt; is the actual argument to the
&lt;code&gt;unsafe_build&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;Reading the LLVM IR code, we’ve learned that Crystal secretly passes a hidden
&lt;code&gt;self&lt;/code&gt; argument to every method call to an object. Then inside each method, the
code has access to &lt;code&gt;self&lt;/code&gt;, to the object instance that code is running for. Some
languages, like Rust, require us to pass &lt;code&gt;self&lt;/code&gt; explicitly in each method call;
in Crystal this behavior is automatic and hidden.&lt;/p&gt;
&lt;h2&gt;Learning How Compilers Work&lt;/h2&gt;
&lt;p&gt;LLVM IR is a simple language designed for compiler engineers. I think of it
like a blank slate for them to write on. Most LLVM instructions are quite
simple and easy to understand; as we saw above, understanding the basic syntax
of the call instruction wasn’t hard at all.&lt;/p&gt;
&lt;p&gt;The hard part was understanding how the Crystal compiler, which targets LLVM
IR, generates code. The LLVM syntax itself was easy to follow; it was the
Crystal language’s implementation that was harder to understand.&lt;/p&gt;
&lt;p&gt;And this is the real reason to learn about LLVM IR syntax. If you take the time
to learn how LLVM instructions work, then you can start to read the code your
favorite language’s compiler generates. And once you can do that, you can learn
more about how your favorite compiler works, and what your programs actually do
when you run them.&lt;/p&gt;
</content></entry><entry><title>Visiting an Abstract Syntax Tree</title><link href="https://patshaughnessy.net/2022/1/22/visiting-an-abstract-syntax-tree" rel="alternate"></link><id href="https://patshaughnessy.net/2022/1/22/visiting-an-abstract-syntax-tree" rel="alternate"></id><published>2022-01-22T00:00:00Z</published><updated>2022-01-22T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 0px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2022/1/22/visit-tree.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Joshua Tree National Park
  &lt;small&gt;(via: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Backpacker_at_Sunset_(22849298523).jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;
  &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;In my &lt;a href=&quot;https://patshaughnessy.net/2021/1</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 0px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2022/1/22/visit-tree.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Joshua Tree National Park
  &lt;small&gt;(via: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Backpacker_at_Sunset_(22849298523).jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;
  &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;In my &lt;a href=&quot;https://patshaughnessy.net/2021/12/22/reading-code-like-a-compiler&quot;&gt;last
post&lt;/a&gt;, I
explored how &lt;a href=&quot;https://crystal-lang.org&quot;&gt;Crystal&lt;/a&gt; parsed a simple program and
produced a data structure called an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax
tree&lt;/a&gt; (AST). But what does
Crystal do with the AST? Why bother going to such lengths to create it?&lt;/p&gt;
&lt;p&gt;After Crystal parses my code, it repeatedly steps through all the entries or
nodes in the AST and builds up a description of the intended meaning and
behavior of my code. This process is known as &lt;em&gt;semantic analysis&lt;/em&gt;. Later,
Crystal will use this description to convert my program into a machine language
executable.&lt;/p&gt;
&lt;p&gt;But what does this description contain? What does it really mean for a compiler
to &lt;em&gt;understand&lt;/em&gt; anything? Let’s pack our bags and visit an abstract syntax tree
with Crystal to find out.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;h2&gt;The Visitor Pattern&lt;/h2&gt;
&lt;p&gt;Imagine several tourists visiting a famous tree: Each of them sees the same
tree in a different way. The tree doesn’t change, but the perspective of each
person looking at it is different. They each take a different photo, or
remember different details.&lt;/p&gt;
&lt;p&gt;In Computer Science this separation of the data structure (the tree) from the
algorithms using it (the tourists) is known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Visitor_pattern&quot;&gt;visitor
pattern&lt;/a&gt;. This technique allows
compilers and other programs to run multiple algorithms on the same data
structure without making a mess.&lt;/p&gt;
&lt;p&gt;The visitor pattern calls for two functions: &lt;code&gt;accept&lt;/code&gt; and &lt;code&gt;visit&lt;/code&gt;. First, a
node in the data structure “accepts” a visitor:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;400px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/visitor1.svg&quot;&gt;
&lt;p&gt;After accepting a visitor, the node turns around and calls the &lt;code&gt;visit&lt;/code&gt; method on
&lt;code&gt;Visitor&lt;/code&gt;:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;400px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/visitor2.svg&quot;&gt;
&lt;p&gt;The &lt;code&gt;visit&lt;/code&gt; method implements whatever algorithm that visitor is interested in.&lt;/p&gt;
&lt;p&gt;This seems kind of pointless… why use &lt;code&gt;accept&lt;/code&gt; at all? We could just call
&lt;code&gt;visit&lt;/code&gt; directly. The key is that, after calling the visitor and passing
itself, the node passes the visitor to each of its children, recursively:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;400px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/visitor3.svg&quot;&gt;
&lt;p&gt;And then the visitor can visit each of the child nodes also. The &lt;code&gt;Visitor&lt;/code&gt;
class doesn’t necessarily need to know anything about how to navigate the node
data structure. And more and more visitor classes can implement new algorithms
without changing the underlying data structure and breaking each other.&lt;/p&gt;
&lt;h2&gt;The Visitor Pattern in the Crystal Compiler&lt;/h2&gt;
&lt;p&gt;In order to understand what my code means, Crystal reads through my program’s
AST over and over again using different visitors. Each algorithm looks for
certain syntax, records information about the types and objects my code uses or
possibly even transforms my code into a different form.&lt;/p&gt;
&lt;div style=&quot;float: right; padding: 8px 0px 0px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2022/1/22/angel-oak.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;A photo I took in 2018 of &lt;a href=&quot;https://en.wikipedia.org/wiki/Angel_Oak&quot;&gt;Angel Oak&lt;/a&gt;,&lt;br/&gt; a 400-500 year old tree in South Carolina.&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Crystal implements the basics of the visitor pattern in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/compiler/crystal/syntax/visitor.cr#L24&quot;&gt;visitor.cr&lt;/a&gt;,
inside the superclass of all AST nodes:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ASTNode
&lt;/span&gt;&lt;span style=&quot;color:#343d46;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;accept&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(visitor)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; visitor.visit_any self
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; visitor.visit self
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        accept_children visitor
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      visitor.end_visit self
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      visitor.end_visit_any self
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Each subclass of &lt;code&gt;ASTNode&lt;/code&gt; implements its own version of &lt;code&gt;accept_children&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;My Tiny Crystal Program&lt;/h2&gt;
&lt;p&gt;To get a sense of how the visitor pattern works inside of Crystal, let’s look
at one line of code from my last post:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;As I explained last month, the Crystal parser generates this AST tree fragment:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;400px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/ast1.svg&quot;&gt;
&lt;p&gt;Once the parser is finished and has created this small tree, the Crystal
compiler steps through it a number of different times, looking for classes,
variables, type declarations, etc. Each of these passes through the AST is
performed by a different visitor class: &lt;code&gt;TopLevelVisitor&lt;/code&gt;,
&lt;code&gt;InstanceVarsInitializerVisitor&lt;/code&gt; or &lt;code&gt;ClassVarsInitializerVisitor&lt;/code&gt; among many
others.&lt;/p&gt;
&lt;p&gt;The most important visitor class the Crystal compiler uses is called simply
&lt;code&gt;MainVisitor&lt;/code&gt;. You can find the code for &lt;code&gt;MainVisitor&lt;/code&gt; in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/compiler/crystal/semantic/main_visitor.cr#L26&quot;&gt;main_visitor.cr&lt;/a&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# This is the main visitor of the program, ran after types have been declared
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# and their type declarations (like `@x : Int32`) have been processed.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# This visits the &amp;quot;main&amp;quot; code of the program and resolves calls, instantiates
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# methods and visits them, recursively, with other MainVisitors.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The visitor keeps track of a method&amp;#39;s variables (or the main program, split into
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# several files, in case of top-level code). It keeps track both of the type of a
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# variable at a single point (stored in @vars) and the combined type of all assignments
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# to it (in @meta_vars).
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Call resolution logic is in `Call#recalculate`, where method lookup is done.
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;MainVisitor &lt;/span&gt;&lt;span style=&quot;color:#343d46;&quot;&gt;&amp;lt; &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;SemanticVisitor&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Since Crystal supports typed parameters and method overloading, the visitor
class implements a different &lt;code&gt;visit&lt;/code&gt; method for each type of node that it visits,
for example:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;MainVisitor &lt;/span&gt;&lt;span style=&quot;color:#343d46;&quot;&gt;&amp;lt; &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;SemanticVisitor
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;visit&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(node : Assign)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;visit&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(node : Var)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;visit&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(node : ArrayLiteral)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;visit&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(node : NumberLiteral)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Etc…&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Now let’s look at three examples of what the &lt;code&gt;MainVisitor&lt;/code&gt; class does with my
code: identifying variables, assigning types and expanding array literals. The
Crystal compiler is much too complex to describe in a single blog post, but
hopefully I can give you glimpse into the sort of work Crystal does during
semantic analysis.&lt;/p&gt;
&lt;h2&gt;Identifying Variables&lt;/h2&gt;
&lt;p&gt;Obviously, my example code creates and initializes a variable called &lt;code&gt;arr&lt;/code&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;But how does Crystal identify this variable’s name and value? What does it do
with &lt;code&gt;arr&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;MainVisitor&lt;/code&gt; class starts to process my code by visiting the root node of
this branch of my AST, the &lt;code&gt;Assign&lt;/code&gt; node:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;375px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/visit-assign1.svg&quot;&gt;
&lt;p&gt;As you can see, earlier during the parsing phrase Crystal had saved the target
variable and value of this assign statement in the child AST nodes. The target
variable, &lt;code&gt;arr&lt;/code&gt;, appears in the &lt;code&gt;Var&lt;/code&gt; node, and the value to assign is an
&lt;code&gt;ArrayLiteral&lt;/code&gt; node. The &lt;code&gt;MainVisitor&lt;/code&gt; now knows I declared a new variable, called
&lt;code&gt;arr&lt;/code&gt;, in the current lexical scope. Since my program has no classes, methods or
any other lexical scopes, Crystal saves this variable in a table of variables
for the top level program:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;300px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/table.svg&quot;&gt;
&lt;p&gt;Actually, to be more accurate, there will always be many other variables in
this table along with &lt;code&gt;arr&lt;/code&gt;. All Crystal programs automatically include the
standard library, so Crystal also saves all of the top level variables from the
standard library in this table.&lt;/p&gt;
&lt;p&gt;In a more normal program, there will be many lexical scopes for different
method and class or module definitions, and &lt;code&gt;MainVisitor&lt;/code&gt; will save each
variable in the corresponding table.&lt;/p&gt;
&lt;h2&gt;Assigning Types&lt;/h2&gt;
&lt;p&gt;Probably the most important function of &lt;code&gt;MainVisitor&lt;/code&gt; is to assign a type to each
value in my program. The simplest example of this is when &lt;code&gt;MainVisitor&lt;/code&gt; visits a
&lt;code&gt;NumberLiteral&lt;/code&gt; node:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;300px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/visit-number-literal.svg&quot;&gt;
&lt;p&gt;Looking at the size of the numeric value, Crystal determines the type should be
&lt;code&gt;Int32&lt;/code&gt;. Crystal then saves this type right inside of the &lt;code&gt;NumberLiteral&lt;/code&gt; node:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;114px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/updated-number-literal.svg&quot;&gt;
&lt;p&gt;Strictly speaking, this violates the visitor pattern because the visitors
shouldn’t be modifying the data structure they visit. But the type of each
node, the type of each programming construct in my program, is really an
integral part of that node. In this case the &lt;code&gt;MainVisitor&lt;/code&gt; is really just
completing each node. It’s not changing the structure of the AST in this case…
although as we’ll see in a minute the &lt;code&gt;MainVisitor&lt;/code&gt; does this for other nodes!&lt;/p&gt;
&lt;h2&gt;Type Inference&lt;/h2&gt;
&lt;p&gt;Sometimes type values can’t be determined from the intrinsic value of an AST
node. Often the type of a node is determined by other nodes in the AST.&lt;/p&gt;
&lt;p&gt;Recall my example line of code is:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Here Crystal automatically sets the type of the arr variable to the type of the
array literal expression: &lt;code&gt;Array(Int32)&lt;/code&gt;. In Computer Science, this is known as
&lt;em&gt;type inference&lt;/em&gt;. Because Crystal can automatically determine the type of
&lt;code&gt;arr&lt;/code&gt;, I don’t need to declare it explicitly by writing something more
complicated like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; uninitialized Array(Int32)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Type inference allows me to write concise, clean code with fewer type
annotations. Most modern, statically typed languages such as Swift, Rust,
Julia, Kotlin, etc., use type inference in the same way as Crystal. Even newer
versions of Java or C++ use type inference.&lt;/p&gt;
&lt;p&gt;The Crystal compiler implements type inference when the MainVisitor encounters
an &lt;code&gt;Assign&lt;/code&gt; AST node, what we saw above.&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;375px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/visit-assign1.svg&quot;&gt;
&lt;p&gt;After encountering the &lt;code&gt;Assign&lt;/code&gt; node, Crystal recursively processes one of the
two child nodes, the &lt;code&gt;ArrayLiteral&lt;/code&gt; value, and its child nodes. When this process
finishes, Crystal knows the type of the &lt;code&gt;ArrayLiteral&lt;/code&gt; node is &lt;code&gt;Array(Int32)&lt;/code&gt;:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;425px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/set-type.svg&quot;&gt;
&lt;p&gt;I’ll take a closer look at how Crystal processes the &lt;code&gt;ArrayLiteral&lt;/code&gt; node next.
But for now, once Crystal has the type of the &lt;code&gt;ArrayLiteral&lt;/code&gt; node it copies that
type over to the &lt;code&gt;Var&lt;/code&gt; node and sets its type also:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;425px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/set-type2.svg&quot;&gt;
&lt;p&gt;But Crystal does something else interesting here: It sets up a dependency
between the two AST nodes: it “binds” the variable to the value:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;325px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/bind.svg&quot;&gt;
&lt;p&gt;This binding dependency allows Crystal to later update the type of the &lt;code&gt;arr&lt;/code&gt;
variable whenever necessary. In this case the value &lt;code&gt;[12345, 67890]&lt;/code&gt; will always
have the same type, but I suspect that sometimes the Crystal compiler can
update types during semantic analysis. In this way if the Crystal compiler ever
changed its mind about the type of some value, it can easy update the types of
any dependent values. I also suspect Crystal uses these type dependency
connections to produce error messages whenever you pass an incorrect type to
some function, for example. These are just guesses, however; if anyone from the
Crystal team knows exactly what these type bindings are used for let me know.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; Ary Borenszweig explained that sometimes the Crystal compiler
updates the type of variables based on how they are used. He posted an
interesting example on &lt;a href=&quot;https://forum.crystal-lang.org/t/visiting-an-abstract-syntax-tree/4304&quot;&gt;The Crystal Programming Language
Forum&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Expanding an Array Literal&lt;/h2&gt;
&lt;p&gt;So far we’ve seen Crystal set the type of the &lt;code&gt;NumberLiteral&lt;/code&gt; node to &lt;code&gt;Int32&lt;/code&gt;,
and we’ve seen Crystal assign &lt;code&gt;arr&lt;/code&gt; a type of &lt;code&gt;Array(Int32)&lt;/code&gt;. But how did Crystal
determine the type of the array literal &lt;code&gt;[12345, 67890]&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;This is where things get even more complicated. Sometimes during semantic
analysis the Crystal compiler completely rewrites parts of your code, replacing
it with something else. This happens even with my simple example. When visiting
the &lt;code&gt;ArrayLiteral&lt;/code&gt; node, the &lt;code&gt;MainVisitor&lt;/code&gt; expands this simple line of code into
something more complex:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;__temp_621 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;::Array(typeof(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)).unsafe_build(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;__temp_622 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; __temp_621.to_unsafe
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;__temp_622[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;__temp_622[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;__temp_621&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Reading this, you can see how later my compiled program will create the new
array. First Crystal creates an empty array with a capacity of 2, and an
element type of &lt;code&gt;Int32&lt;/code&gt;. &lt;code&gt;typeof(12345, 67890)&lt;/code&gt; returns the type (or multiple
types inside a union type) found in the given set of values, in this case just
&lt;code&gt;Int32&lt;/code&gt;. Later Crystal sets the two elements in the array just by assigning
them.&lt;/p&gt;
&lt;p&gt;Crystal achieves this by replacing part of my program’s AST with a new branch:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;375px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/expanded-ast.svg&quot;&gt;
&lt;p&gt;For clarity, I’m not drawing the AST nodes for the inner assign operations,
only the first line:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;__temp_621 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;::Array(typeof(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)).unsafe_build(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Putting It All Together&lt;/h2&gt;
&lt;p&gt;With this new, updated AST we can see exactly how Crystal determines the type
of my variable &lt;code&gt;arr&lt;/code&gt;. Starting at the root of my AST, &lt;code&gt;MainVisitor&lt;/code&gt; visits all of
the AST nodes in this order in a series of recursive calls:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;114px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/call-recurse.svg&quot;&gt;
&lt;p&gt;And it determines the types of each of these nodes as it returns from the
recursive calls:&lt;/p&gt;
&lt;img class=&quot;svg&quot; width=&quot;240px&quot; src=&quot;https://patshaughnessy.net/assets/2022/1/22/return-recurse.svg&quot;&gt;
&lt;p&gt;Some interesting details here that I don’t understand completely or have space
to explain here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;TypeOf&lt;/code&gt; node calculates a common union type using a type formula. In this
example, it just returns &lt;code&gt;Int32&lt;/code&gt; because both elements of my array, &lt;code&gt;12345&lt;/code&gt; and
&lt;code&gt;67890&lt;/code&gt;, are simple 32 bit integers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I believe the &lt;code&gt;Generic&lt;/code&gt; node refers to a Crystal generic class via the &lt;code&gt;Path&lt;/code&gt; node
shown above, in this example &lt;code&gt;Array(T)&lt;/code&gt;. When &lt;code&gt;MainVisitor&lt;/code&gt; processes the &lt;code&gt;Generic&lt;/code&gt;
node, it sets &lt;code&gt;T&lt;/code&gt; to the type &lt;code&gt;Int32&lt;/code&gt;, arriving at the type &lt;code&gt;Array(Int32).class&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;Call&lt;/code&gt; node looks up the method my code is calling (&lt;code&gt;unsafe_build&lt;/code&gt;) and
uses the type from that method’s return value. I didn’t have time to explore
how method lookup works in Crystal, however, so I’m not sure about this.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Scratching the Surface&lt;/h2&gt;
&lt;p&gt;Today we looked at a tiny piece of what the Crystal compiler can do. There are
many more types of AST nodes, each of which the &lt;code&gt;MainVisitor&lt;/code&gt; class handles
differently. And there are many different visitor classes also, beyond
&lt;code&gt;MainVisitor&lt;/code&gt;. When analyzing a more complex program Crystal has to understand
class and module definitions, instance and class variables, type annotations,
different lexical scopes, macros, and much, much more. Crystal will need all of
this information later, during the code generation phase, the next step that
follows semantic analysis.&lt;/p&gt;
&lt;p&gt;But I hope this article gave you a sense of what sort of work a compiler has to
do in order to understand your code. As you can see, for a statically typed
language like Crystal the compiler spends much of its time identifying all of
the types in your code, and determining which programming constructs or AST
nodes have which types.&lt;/p&gt;
&lt;p&gt;Next time I’ll look at code generation: Now that Crystal has identified the
variables, function calls and types in my code it is ready to generate the
machine language code needed to execute my program. To do that, it will
leverage the LLVM framework.&lt;/p&gt;
</content></entry><entry><title>Reading Code Like a Compiler</title><link href="https://patshaughnessy.net/2021/12/22/reading-code-like-a-compiler" rel="alternate"></link><id href="https://patshaughnessy.net/2021/12/22/reading-code-like-a-compiler" rel="alternate"></id><published>2021-12-22T00:00:00Z</published><updated>2021-12-22T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 0px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/depth-of-field.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Imagine trying to read an entire book while &lt;br/&gt;
  focusing on only one or two words at a time
  &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;We use compilers every day to parse our code, find our programming mistakes and
then help us fix them. But h</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 0px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/depth-of-field.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Imagine trying to read an entire book while &lt;br/&gt;
  focusing on only one or two words at a time
  &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;We use compilers every day to parse our code, find our programming mistakes and
then help us fix them. But how do compilers read and understand our code? What
does our code look like to them?&lt;/p&gt;
&lt;p&gt;We tend to read code like we would read a human language like English. We
don’t see letters; we see words and phrases. And in a very natural way we use
what we just read, the proceeding sentence or paragraph, to give us the context
we need to understand the following text. And sometimes we just skim over text
quickly to gleam a bit of the meaning without even reading every word.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;p&gt;Compilers aren’t as smart as we are. They can’t read and understand entire
phrases or sentences all at once. They read text one letter, one word at at
time, meticulously building up a record of what they have read so far.&lt;/p&gt;
&lt;p&gt;I was curious to learn more about how compilers parse text, but where should I
look? Which compiler should I study? Once again, like in my last few posts,
Crystal was the answer.&lt;/p&gt;
&lt;h2&gt;Crystal: A Compiler Accessible to Everyone&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://crystal-lang.org&quot;&gt;Crystal&lt;/a&gt; is a unique combination of simple, human
syntax inspired by Ruby, with the speed and robustness enabled by static types
and the use of &lt;a href=&quot;https://llvm.org&quot;&gt;LLVM&lt;/a&gt;. But for me the most exciting thing
about Crystal is how the Crystal team implemented both its standard library and
compiler using the target language: Crystal. This makes Crystal’s internal
implementation accessible to anyone familiar with Ruby. For once, you don’t
have to be a hard core C or C++ developer to learn how a compiler works.
Reading code not much more complex than a Ruby on Rails web site, I can take a
peek under the hood of a real world compiler to see how it works internally.&lt;/p&gt;
&lt;p&gt;Not only did the Crystal team implement their compiler using Crystal, they also
wrote it by hand. Parsing is such a tedious task that often developers use a
parser generator, such as &lt;a href=&quot;https://www.gnu.org/software/bison/&quot;&gt;GNU Bison&lt;/a&gt;, to
automatically generate the parse code given a set of rules. This is how Ruby
works, for example. But the Crystal team wrote their parser directly in
Crystal, which you can read in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/compiler/crystal/syntax/parser.cr&quot;&gt;parser.cr&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Along with a readable compiler, I need a readable program to compile. I decided to
reuse the same array snippet from my last post:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This tiny Crystal program creates an array of two numbers and then prints out
the second number. Simple enough: You and I can read and parse these two lines
of code in one glance and in a fraction of a second understand what it does.
Even if you’re not a Crystal or Ruby developer this syntax is so simple you can
still understand it.&lt;/p&gt;
&lt;p&gt;But the Crystal compiler can’t understand this code as easily as we can.
Parsing even this simple program is a complex task for a compiler.&lt;/p&gt;
&lt;h2&gt;How the Crystal Compiler Sees My Code&lt;/h2&gt;
&lt;p&gt;Before parsing or running the code above, Crystal converts it into a series of
tokens. To the Crystal compiler, my program looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/tokens.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;The first &lt;code&gt;IDENT&lt;/code&gt; token corresponds to the &lt;code&gt;arr&lt;/code&gt; variable at the beginning of the
first line. You can also see two &lt;code&gt;NUMBER&lt;/code&gt; tokens: the &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/compiler/crystal/syntax/lexer.cr&quot;&gt;Crystal tokenizer
code&lt;/a&gt;
converted each series of numerical digits into single tokens, one for 12345 and
the other for 67890. Along with these tokens you can also see other tokens for
punctuation used in Crystal syntax, like the equals sign and left and right
square brackets. There is also a new line token and one for the end of the
entire file.&lt;/p&gt;
&lt;h2&gt;Reading a Book One Word at a Time&lt;/h2&gt;
&lt;p&gt;To understand my code, Crystal processes these tokens one at a time, stepping
tediously through the entire program. What a slow, painful process!&lt;/p&gt;
&lt;p&gt;How would we read if we could only see one word at a time? I imagine covering
the book I’m trying to read with a piece of paper or plastic that had a small
hole in it… and that through the hole I could only see one word at a time. How
would I read one entire page? Well, I’d have to move the paper around, showing
one word and then another and another. And how would I know where to move the
paper next? Would I simply move the paper forward one word at at time? What if
I forgot some word I had seen earlier? I’d have to backtrack - but how far back
to go? What if the meaning of the word I was looking at depended on the words
that followed it? This sounds like a nightmare.&lt;/p&gt;
&lt;p&gt;To read like this, if it was even possible at all, I’d have to have a well
thought out strategy. I’d have to know exactly how to move that plastic screen
around. When you can only read one word at a time, deciding which word to read
next becomes incredibly important. I would need an algorithm to follow.&lt;/p&gt;
&lt;p&gt;This is what a parser algorithm is: Some set of rules the parse code can use to
interpret each word, and, equally important, to decide which word to read next.
Crystal’s parse code is over 6000 lines long, so I won’t attempt to completely
explain it here. But there’s an underlying, high level algorithm the parse code
uses:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/pattern-recurse-record.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;First, the parser compares the current token, and possibly the following or
previous tokens as well, to a series of expected patterns. These patterns
define the syntax the parser is reading.  Second, the parser recurses. It calls
itself to parse the next token, or possibly multiple next tokens depending on
which pattern the parser just matched. Finally, the parser records what it saw:
which pattern matched the current token and the results of the recursive calls
to itself, for future reference.&lt;/p&gt;
&lt;h2&gt;Matching a Pattern&lt;/h2&gt;
&lt;p&gt;The best way to understand how this works is to see it in action. Let’s follow
along with the Crystal compiler as it parses the code I showed above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Recall Crystal already converted this code into a token stream:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/token-line.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;(To be more accurate, Crystal actually converts my code into tokens as it goes.
The parse code calls the tokenizer code each time it needs a new token. But
this timing isn’t really important.)&lt;/p&gt;
&lt;p&gt;As you might expect, Crystal starts with the first token, &lt;code&gt;IDENT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/process-token1.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;What does this mean? How does Crystal interpret &lt;code&gt;arr&lt;/code&gt;? &lt;code&gt;IDENT&lt;/code&gt; is short for
identifier, but what role does this identifier play? What meaning does &lt;code&gt;arr&lt;/code&gt; have
in my code?&lt;/p&gt;
&lt;p&gt;To decide on the correct meaning, the Crystal parser compares the &lt;code&gt;IDENT&lt;/code&gt; token
with a series of patterns. For example Crystal looks for patterns like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a ternary expression &lt;code&gt;a ? b : c&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a range &lt;code&gt;a..b&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;an expression using a binary operator, such as: &lt;code&gt;a + b&lt;/code&gt;, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and many more…&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It turns out none of these patterns apply in this case, and Crystal ends up
selecting a default pattern which handles the most common code pattern: a
function call. Crystal decides that when I wrote &lt;code&gt;arr&lt;/code&gt; I intended to call a
function called &lt;code&gt;arr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I often tell people I work with at my day job that I have really bad memory.
And it’s true. I constantly have to google the syntax or return values of
functions. I often forget what some code means even just a month after I wrote
it. And the Crystal compiler is no better: As soon as it processes that &lt;code&gt;IDENT&lt;/code&gt;
token above, it has to write down what it decided that token meant or else it
would forget.&lt;/p&gt;
&lt;p&gt;To record the function call, Crystal creates an object:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/ast1.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;As we’ll see in a moment, Crystal builds up a tree of these objects, called an
&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;Abstract Syntax
Tree&lt;/a&gt; (AST). The AST will
later serve as a record of the syntactic structure of my code.&lt;/p&gt;
&lt;h2&gt;Recursively Calling Itself&lt;/h2&gt;
&lt;p&gt;Parsing is inherently a recursive process. Unlike English text, Crystal
expressions can be nested one inside another to any depth. Although I suppose
English grammar is somewhat recursive and can be nested to some degree. I
wonder if the grammars for some other human languages are more recursive than
English? Interesting question.&lt;/p&gt;
&lt;p&gt;For parsing a programming language like Crystal, the simplest thing for the
parser code to do is recursively call itself. And it does this based on the
pattern it just matched. For example, if Crystal had parsed a plus sign, it
would need to recursively call itself to parse the values that appeared before
and after the plus.&lt;/p&gt;
&lt;p&gt;In this example, Crystal has to decide what arguments to pass to this call to
the &lt;code&gt;arr&lt;/code&gt; function. Did I write &lt;code&gt;arr(1, 2, 3)&lt;/code&gt; or just &lt;code&gt;arr&lt;/code&gt;? Or &lt;code&gt;arr()&lt;/code&gt;? What were
the values 1, 2 and 3? Each of these could be a complex expression in their own
right, maybe appearing inside of parentheses, a compound value like an array or
maybe yet another function call.&lt;/p&gt;
&lt;p&gt;To find the arguments of the function call, inside the recursive call to the
parse code Crystal proceeds forward to process the next two tokens:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/process-token2.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Crystal skips over the space, and then encounters the equals sign. Suddenly
Crystal realizes it was wrong! The &lt;code&gt;arr&lt;/code&gt; identifier wasn’t a reference to a
function at all, it was a variable declaration. Yes, sometimes compilers change
their minds while reading, just like we do!&lt;/p&gt;
&lt;h2&gt;Recording an AST Node&lt;/h2&gt;
&lt;p&gt;To record this new, revised syntax, Crystal changes the &lt;code&gt;Call&lt;/code&gt; AST node it
created earlier to an &lt;code&gt;Assign&lt;/code&gt; AST node, and creates a new &lt;code&gt;Var&lt;/code&gt; AST node to
record the variable being assigned to:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/ast2.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Now the AST is starting to resemble a tree. Because of the recursive nature of
parse algorithm, this tree structure is an ideal way of record what the
compiler has parsed so far. Trees are recursive too: Each branch is a tree in
its own right.&lt;/p&gt;
&lt;h2&gt;Rinse and Repeat&lt;/h2&gt;
&lt;p&gt;But what value should Crystal assign to that variable? What should appear in
the AST as the value attribute of the &lt;code&gt;Assign&lt;/code&gt; node?&lt;/p&gt;
&lt;p&gt;To find out, the Crystal compiler recursively calls the same parsing algorithm
again, but starting with the &lt;code&gt;[&lt;/code&gt; token:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/process-token3.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Following the pattern match, record and recurse process, the Crystal compiler
once again matches the new token, &lt;code&gt;[&lt;/code&gt;, with a series of expected patterns. This
time, Crystal decides that the left bracket is the start of literal array
expression and records a new AST node:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/array-literal1.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;But before inserting it into the syntax tree, Crystal recursively calls itself
to parse each of the values that appear in the array. The array literal pattern
expects a series of values to appear separated by spaces, so Crystal proceeds
to process the following tokens, looking for values separated by commas:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/process-token4.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;After encountering the comma, Crystal recursively calls the same parse code
again on the previous token or tokens that appeared before the comma, because
the array value before the comma could be another expression of arbitrary depth
and complexity. In this example, Crystal finds a simple numeric array element,
and creates a new AST node to represent the numeric value:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/number-literal1.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;After reading the comma, Crystal calls its parser recursively again, and finds
the second number:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/number-literal2.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Remember Crystal has a bad memory. With all these new AST nodes, Crystal will
quickly forget what they mean. Fortunately, Crystal reads in the right square
bracket and realizes I ended the array literal in my code:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/process-token5.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Now those recursive calls to the parse code return, and Crystal assembles these
new AST nodes:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/array-literal2.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;…and then places them inside the larger, surrounding AST:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/12/22/ast3.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;After this, these recursive calls return and the Crystal compiler moves on to
parse the second line of my program.&lt;/p&gt;
&lt;h2&gt;A Complete Abstract Syntax Tree&lt;/h2&gt;
&lt;p&gt;After following the Crystal parser for a while, I added some debug logging code
to the compiler so I could see the result. Here’s my example code again:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;And here’s the complete AST the Crystal compiler generated after parsing my
code. My debug logging indented each line to indicate the AST structure:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;&amp;lt;Crystal::Expressions exp_count=3 &gt;
  &amp;lt;Crystal::Require string=prelude &gt;
  &amp;lt;Crystal::Assign target=Crystal::Var value=Crystal::ArrayLiteral &gt;
    &amp;lt;Crystal::Var name=arr &gt;
    &amp;lt;Crystal::ArrayLiteral element_count=2 of=Nil name=Nil &gt;
      &amp;lt;Crystal::NumberLiteral number=12345 kind=i32 &gt;
      &amp;lt;Crystal::NumberLiteral number=67890 kind=i32 &gt;
  &amp;lt;Crystal::Call obj= name=puts arg_count=1 &gt;
    &amp;lt;Crystal::Call obj=arr name=[] arg_count=1 &gt;
      &amp;lt;Crystal::Var name=arr &gt;
      &amp;lt;Crystal::NumberLiteral number=1 kind=i32 &gt;&lt;/pre&gt;
&lt;p&gt;Each of these values is a subclass of the &lt;code&gt;Crystal::ASTNode&lt;/code&gt; superclass.
Crystal defines all of these in the
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/compiler/crystal/syntax/ast.cr&quot;&gt;ast.cr&lt;/a&gt;
file. Some interesting details to note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The top level node is called &lt;code&gt;Expressions&lt;/code&gt;, and more or less holds one
expression per line of code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The second node, the first child node of &lt;code&gt;Expressions&lt;/code&gt;, is called &lt;code&gt;Require&lt;/code&gt;.
The surprise here is that I didn’t even put a &lt;code&gt;require&lt;/code&gt; keyword in my
program! Crystal silently inserts &lt;code&gt;require prelude&lt;/code&gt; to the beginning of
all Crystal programs. The “prelude” is the Crystal standard library, the code
that defines &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt; many other core classes. Reading the AST allows
us to see how the Crystal compiler does this automatically.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The third node and its children are the nodes we saw Crystal create above for
my first line of code, the array literal and the variable it is assigned to.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finally, the last branch of the tree shows the call to &lt;code&gt;puts&lt;/code&gt;. This time
Crystal’s default guess about identifiers being function calls was correct.
Another interesting detail here is that the inner call to the &lt;code&gt;[]&lt;/code&gt; function
was not generated by an identifier, but by the &lt;code&gt;[&lt;/code&gt; token. This was one of the
patterns the Crystal parser checked for after one of the recursive parse
calls.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Next Time&lt;/h2&gt;
&lt;p&gt;What’s the point of all of this? What does the Crystal compiler do next with
the AST? This tree structure is a fantastic summary of how Crystal parsed my
code, and, as we’ll see later, also provides a convenient way for Crystal later
to process my code and transform it in different ways.&lt;/p&gt;
&lt;p&gt;When I have time, I plan to write a few more posts about more of the inner
workings of the Crystal compiler and the LLVM framework, which Crystal later
uses to generate my x86 executable program.&lt;/p&gt;
</content></entry><entry><title>Find Your Language’s Primitives</title><link href="https://patshaughnessy.net/2021/11/29/find-your-languages-primitives" rel="alternate"></link><id href="https://patshaughnessy.net/2021/11/29/find-your-languages-primitives" rel="alternate"></id><published>2021-11-29T00:00:00Z</published><updated>2021-11-29T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: right; padding: 8px 0px 30px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/dig1.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;If you dig into your programming language's syntax, you might &lt;br/&gt;discover that it is capable of much more than you thought it was.
  &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Wikipedia defines “Language Primitive” &lt;a href=&quot;https://en.wikipedia.org/wi</summary><content type="html">&lt;div style=&quot;float: right; padding: 8px 0px 30px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/dig1.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;If you dig into your programming language's syntax, you might &lt;br/&gt;discover that it is capable of much more than you thought it was.
  &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Wikipedia defines “Language Primitive” &lt;a href=&quot;https://en.wikipedia.org/wiki/Language_primitive&quot;&gt;this
way&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
In computing, language primitives are the simplest elements available in a
programming language. A primitive is the smallest 'unit of processing'
available to a programmer of a given machine, or can be an atomic element of an
expression in a language.
&lt;/blockquote&gt;
&lt;p&gt;By looking at a language’s primitives, we can learn what kind of code will be
easy to write or impossible to express, and what types of problems the language
was intended to solve.  Whether you’ve been using a language for years, or just
now learning a new language for fun, take the time to find and learn about your
language’s primitives. You might discover something you never knew, and will
come away with a deeper understanding of how your programs work.&lt;/p&gt;
&lt;p&gt;As an example today, I’m going to look at how arrays work in three languages:
Ruby, Crystal and x86 Assembly Language.&lt;/p&gt;
&lt;h2&gt;Retrieving an Array Element In Ruby&lt;/h2&gt;
&lt;p&gt;In Ruby I can create an array and later access an element like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This code would be the same or almost the same in many other programming
languages. It just means: “find the second element of the array and print it to
stdout.”&lt;/p&gt;
&lt;p&gt;But how does this actually work? In Ruby, the &lt;span class=&quot;code&quot;&gt;Array&lt;/span&gt;
class and all of its methods are language primitives. This means array methods
like &lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;[]=&lt;/span&gt; cannot be
broken down into smaller pieces of Ruby code. As Wikipedia says, these methods
are the smallest unit of processing available to Ruby programmers working with
arrays.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/primitive1.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Ruby hides the details of how arrays actually work from us. To learn how Ruby
actually saves and retrieves values from an array, we would need to switch
languages and drop down a level of abstraction, and read the C implementation
in the Ruby source code:
&lt;a href=&quot;https://github.com/ruby/ruby/blob/master/array.c&quot;&gt;array.c&lt;/a&gt;. There’s nothing
wrong with this, of course. Ruby developers use arrays every day without any
trouble. But switching from Ruby to C makes understanding internal details much
more difficult.&lt;/p&gt;
&lt;h2&gt;Retrieving an Array Element In Crystal&lt;/h2&gt;
&lt;p&gt;This Fall I decided to learn more about &lt;a href=&quot;https://crystal-lang.org&quot;&gt;Crystal&lt;/a&gt;, a
statically typed language with syntax that resembles Ruby. I expected to find a
similar &lt;span class=&quot;code&quot;&gt;Array#[]&lt;/span&gt; primitive.  But surprisingly, I was
wrong!&lt;/p&gt;
&lt;p&gt;The same code from above also works in Crystal:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;In Crystal, arrays are not language primitives because the Crystal standard
library implements arrays using Crystal itself. The &lt;span
class=&quot;code&quot;&gt;Array#[]&lt;/span&gt; method is not the smallest unit of processing
available to Crystal programmers. Let’s dig into the details and divide up the
&lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; method into smaller and smaller pieces to see how
the Crystal team implemented it.&lt;/p&gt;
&lt;p&gt;Reading
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/indexable.cr#L56&quot;&gt;src/indexable.cr&lt;/a&gt;
in the Crystal standard library, here’s the implementation of &lt;span class=&quot;code&quot;&gt;Indexable#[]&lt;/span&gt;
which the array class uses when I call &lt;span class=&quot;code&quot;&gt;arr[1]&lt;/span&gt; above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# Returns the element at the given *index*.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Negative indices can be used to start counting from the end of the array.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Raises `IndexError` if trying to access an element outside the array&amp;#39;s range.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[0]  # =&amp;gt; &amp;#39;a&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[2]  # =&amp;gt; &amp;#39;c&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[-1] # =&amp;gt; &amp;#39;c&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[-2] # =&amp;gt; &amp;#39;b&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[3]  # raises IndexError
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[-4] # raises IndexError
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;@[AlwaysInline]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;[]&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  fetch(index) { &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;raise &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;IndexError&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The Crystal team implemented &lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; using another method
called &lt;span class=&quot;code&quot;&gt;fetch&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# Returns the element at the given *index*, if in bounds,
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# otherwise executes the given block with the index and returns its value.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# a = [:foo, :bar]
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# a.fetch(0) { :default_value }    # =&amp;gt; :foo
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# a.fetch(2) { :default_value }    # =&amp;gt; :default_value
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# a.fetch(2) { |index| index * 3 } # =&amp;gt; 6
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;fetch&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  index &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; check_index_out_of_bounds(index) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return yield &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;index
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  unsafe_fetch(index)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Neither the &lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; operator nor the &lt;span
class=&quot;code&quot;&gt;fetch&lt;/span&gt; method are language primitives. To find a language
primitive, I need to keep dividing the code up into smaller and smaller pieces,
until it can’t be divided any further. The same process a chemist would use to
break up some material into smaller and smaller molecules until they are left
with a set of atoms.&lt;/p&gt;
&lt;p&gt;Let’s continue by reading &lt;span class=&quot;code&quot;&gt;unsafe_fetch&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# Returns the element at the given *index*, without doing any bounds check.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# `Indexable` makes sure to invoke this method with *index* in `0...size`,
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# so converting negative indices to positive ones is not needed here.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Clients never invoke this method directly. Instead, they access
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# elements with `#[](index)` and `#[]?(index)`.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# This method should only be directly invoked if you are absolutely
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# sure the index is in bounds, to avoid a bounds check for a small boost
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# of performance.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;abstract &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;unsafe_fetch&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;span class=&quot;code&quot;&gt;Indexable#unsafe_fetch&lt;/span&gt; is an abstract method, I
need to read how the &lt;span class=&quot;code&quot;&gt;Array&lt;/span&gt; class implements it back
in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr#L663&quot;&gt;src/array.cr&lt;/a&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;@[AlwaysInline]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;unsafe_fetch&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;T
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer[index]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;div style=&quot;float: right; padding: 8px 0px 30px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/dig2.jpg&quot;&gt;&lt;br/&gt;
	&lt;i&gt;&lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Digging_in_permafrost.jpg&quot;&gt;Nick Bonzey via Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;So far, I’ve drilled down through 3 levels of Crystal implementation:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/primitive2.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;But I haven’t found a primitive function yet. Let’s keep digging!&lt;/p&gt;
&lt;h2&gt;The Crystal Array Class&lt;/h2&gt;
&lt;p&gt;To learn more, I need to scroll up and read the beginning of the Crystal &lt;span
class=&quot;code&quot;&gt;Array&lt;/span&gt; class definition:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# An `Array` is an ordered, integer-indexed collection of objects of type T.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Array indexing starts at 0. A negative index is assumed to be
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# relative to the end of the array: -1 indicates the last element,
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# -2 is the next to last element, and so on.&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;etc...&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# An `Array` is implemented using an internal buffer of some capacity
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# and is reallocated when elements are pushed to it when more capacity
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# is needed. This is normally known as a [dynamic array](http://en.wikipedia.org/wiki/Dynamic_array).
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;etc...&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# The buffer where elements start.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Pointer(T)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;I’ve deleted some of the comments and code for clarity. You can read the full,
original version in &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr&quot;&gt;src/array.cr.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now I get a sense of how the &lt;span class=&quot;code&quot;&gt;unsafe_fetch&lt;/span&gt; method
above works. Let’s repeat that again:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;unsafe_fetch&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;T
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer[index]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal saves all of the elements in each array into a memory buffer called
&lt;span class=&quot;code&quot;&gt;@buffer&lt;/span&gt;. And when I access an element of the array
like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal first checks that the array index (1 in this example) is valid, and
then loads the array element I want from the buffer using: &lt;span
class=&quot;code&quot;&gt;@buffer[1]&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;The Crystal Pointer Class&lt;/h2&gt;
&lt;p&gt;But how does &lt;span class=&quot;code&quot;&gt;@buffer[index]&lt;/span&gt; actually work? I haven’t learned anything yet! I’m
just going around in circles. So far all I’ve been able to find is that Crystal
implements &lt;span class=&quot;code&quot;&gt;Array#[]&lt;/span&gt; with a different &lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; operator, on a different class. What
type of object is &lt;span class=&quot;code&quot;&gt;@buffer&lt;/span&gt;? What does it do?&lt;/p&gt;
&lt;p&gt;Reading the array class declaration again more carefully, I can see that
&lt;span class=&quot;code&quot;&gt;@buffer&lt;/span&gt; is an instance of the &lt;span class=&quot;code&quot;&gt;Pointer&lt;/span&gt; class:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# The buffer where elements start.
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Pointer(T)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Let’s read how Crystal implements &lt;span class=&quot;code&quot;&gt;Pointer#[]&lt;/span&gt; in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/pointer.cr#L107&quot;&gt;src/pointer.cr:&lt;/a&gt;&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# Gets the value pointed at this pointer&amp;#39;s address plus `offset * sizeof(T)`.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr = Pointer.malloc(4) { |i| i + 10 }
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr[0] # =&amp;gt; 10
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr[1] # =&amp;gt; 11
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr[2] # =&amp;gt; 12
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr[3] # =&amp;gt; 13
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;[]&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(offset)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  (self &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; offset).value
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Reading this, I discovered the Crystal team has written a class that represents
pointers! Just like using a pointer in C, Crystal code can refer to and access
any memory location directly. Because the &lt;span class=&quot;code&quot;&gt;Pointer&lt;/span&gt;
class is part of the language, Crystal allows us to implement our own data
structures and algorithms in a very detailed manner, allocating and accessing
memory just like the Crystal team has while implementing arrays, hashes and
other classes.&lt;/p&gt;
&lt;p&gt;Now I’ve dug down through 4 levels of Crystal function calls, but I still
haven’t found a language primitive yet.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/primitive3.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;A Crystal Language Primitive&lt;/h2&gt;
&lt;p&gt;We still haven’t discovered how arrays actually work - how pointers actually
work. That is, reading this line of code above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;(self &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; offset).value&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;…I understand the meaning and intent of pointer arithmetic, and how it’s used
by Crystal arrays, but I still don’t see how or where Crystal actually obtains
the array element referenced by a given pointer.&lt;/p&gt;
&lt;p&gt;Digging deeper, let’s read the &lt;span class=&quot;code&quot;&gt;Pointer#value&lt;/span&gt; method
to find out - this method’s implementation should tell me exactly how Crystal
obtains the value:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# Gets the value pointed by this pointer.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr = Pointer(Int32).malloc(4)
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr.value = 42
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr.value # =&amp;gt; 42
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;@[Primitive(&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;:pointer_get&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;value&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; : T
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, this is a language primitive - it says “primitive” right there
above the method definition!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/primitive4.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Returning to Wikipedia’s definition of a language primitive, this is an atomic
element of an expression. The Crystal compiler knows not to try to compile this
code but to assume this behavior is part of the language. In fact, there is no
implementation for &lt;span class=&quot;code&quot;&gt;Pointer#value&lt;/span&gt; here at all: the
method is empty!&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;value&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; : T
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The empty &lt;span class=&quot;code&quot;&gt;value&lt;/span&gt; method above doesn’t tell us where
the value actually comes from, or how Crystal obtains it. To learn that, we
need to step down one level of abstraction - we need to use a lower level
language, not Crystal.&lt;/p&gt;
&lt;h2&gt;Retrieving an Array Element In x86 Assembly Language&lt;/h2&gt;
&lt;div style=&quot;float: right; padding: 18px 0px 30px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/cave.png&quot;&gt;&lt;br/&gt;
&lt;/div&gt;
&lt;p&gt;What lower level language should we use? Since the Crystal team used the &lt;a href=&quot;https://llvm.org&quot;&gt;Low
Level Virtual Machine (LLVM)&lt;/a&gt; project to implement their
compiler, I could look at LLVM’s low level instruction language. But since I’m
not familiar with that, or with how the Crystal compiler works, I decided to
jump down to the lowest level of abstraction available to me on my Intel Mac:
x86 Assembly Language.&lt;/p&gt;
&lt;p&gt;Here’s my Crystal program again:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;$ cat array_example.cr
arr = [12345, 67890]
puts arr[1]&lt;/pre&gt;
&lt;p&gt;If I compile the program without running it, and then use the &lt;span
class=&quot;code&quot;&gt;llvm-objdump&lt;/span&gt; command, LLVM will give me a version of my
code converted into Intel x86 Assembly Language:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;$ crystal build array_example.cr
$ llvm-objdump -D array_example &gt; array_example.a&lt;/pre&gt;
&lt;p&gt;Now by reading the assembly produced by the Crystal compiler and LLVM, I can
see how the &lt;span class=&quot;code&quot;&gt;Pointer#[]&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;Pointer#value&lt;/span&gt; methods actually work:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;0000000100089bb0 &lt;_*Pointer(Int32)@Pointer(T)#[]&lt;Int32&gt;:Int32&gt;:
100089bb0: 50                           pushq %rax
100089bb1: e8 0a 00 00 00               callq 0x100089bc0 &lt;_*Pointer(Int32)@Pointer(T)#+&lt;Int32&gt;:Pointer(Int32)&gt;
100089bb6: 8b 00                        movl  (%rax), %eax
100089bb8: 59                           popq  %rcx
100089bb9: c3                           retq

0000000100089bc0 &lt;_*Pointer(Int32)@Pointer(T)#+&lt;Int32&gt;:Pointer(Int32)&gt;:
100089bc0: 48 63 c6                     movslq  %esi, %rax
100089bc3: 48 c1 e0 02                  shlq  $2, %rax
100089bc7: 48 01 c7                     addq  %rax, %rdi
100089bca: 48 89 f8                     movq  %rdi, %rax
100089bcd: c3                           retq&lt;/pre&gt;
&lt;p&gt;Assembly language is just another programming language like any other, but with
a different set of primitives. The primitives in this language are hardware
instructions that my laptop’s CPU can understand and execute directly:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/primitive5.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;I won’t pretend to understand all the details here, but if you’re curious about
what this code does - how my compiled Crystal program actually retrieves a
value from an array - here are a few highlights you can look for:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/29/assembly-table.svg&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;If you’d like to learn more about x86 assembly language, I wrote an article a
few years ago explaining some of the basics: &lt;a href=&quot;https://patshaughnessy.net/2016/11/26/learning-to-read-x86-assembly-language&quot;&gt;Learning to Read x86 Assembly
Language&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Understand the Primitives of the Language You Are Using&lt;/h2&gt;
&lt;p&gt;Why did I bother with this exercise? To make sure I deeply understand the
programming languages I’m using. Ruby hides much of its implementation in C, so
I didn’t learn much looking at the Ruby array primitives in this example. And
the primitive functions of assembly language are by definition the instructions
my CPU can execute directly. It’s always fun trying to identify and understand
machine level instructions!&lt;/p&gt;
&lt;p&gt;But Crystal surprised me - I expected to see a set of primitive array functions
like we have in Ruby, but I was wrong. Instead, I learned that Crystal supports
pointers, just like C or other low level languages do. I discovered that
Crystal, unlike Ruby, might be an appropriate choice for low level systems
programming tasks. And I was able to learn all of this, along with the array
implementation details, because the Crystal team implemented its standard
library in the same, target language: Crystal. All I had to do was make an
effort to read some code.&lt;/p&gt;
&lt;p&gt;Dive into details and find out what the language primitives are in your
favorite programming language. You might be surprised and discover that your
language is capable of much more than you thought it was.&lt;/p&gt;
</content></entry><entry><title>Generic Types: Adding Math Puzzles To Your Code</title><link href="https://patshaughnessy.net/2021/11/6/generic-types-adding-math-puzzles-to-your-code" rel="alternate"></link><id href="https://patshaughnessy.net/2021/11/6/generic-types-adding-math-puzzles-to-your-code" rel="alternate"></id><published>2021-11-06T00:00:00Z</published><updated>2021-11-06T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/6/formula.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;In this formula, x is the bound variable, a is&lt;br/&gt;the free variable and e is constant.&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Most modern, statically typed languages allow us to use generic types. We write
a function once with generic type syntax, and </summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/11/6/formula.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;In this formula, x is the bound variable, a is&lt;br/&gt;the free variable and e is constant.&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Most modern, statically typed languages allow us to use generic types. We write
a function once with generic type syntax, and then the compiler can apply the
same code over and over again to different actual, concrete types. Hence the
name &lt;em&gt;generic&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is a powerful language feature, but generic code is often confusing and
hard to read. For me, generic code resembles something from my high school
algebra textbook. I see small math puzzles sprinkled around my computer
program. Why do this? Why add math problems to your code? Computer programming
is already hard enough; why make it even more complicated?&lt;/p&gt;
&lt;p&gt;Generic types allow us to get the best of both words: the safety and
performance of static types, with the flexibility and simplicity of a dynamic,
typeless language.&lt;/p&gt;
&lt;p&gt;But this comes at a steep price: Using generic types force you to write two
programs, in a sense. Your normal code for runtime, and a second, parallel
type-specific program that runs at compile time. To see what I mean, let’s take
an example from the &lt;a href=&quot;https://github.com/crystal-lang/crystal/tree/master/src&quot;&gt;Crystal standard
library&lt;/a&gt; and explore
how the Crystal team used generic type syntax to implement their array class.&lt;/p&gt;
&lt;h2&gt;Array#uniq in Crystal&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://patshaughnessy.net/2021/10/23/to-learn-a-new-language-read-its-standard-library&quot;&gt;Last
time&lt;/a&gt;
I looked at the Crystal standard library, specifically at how Crystal removes
duplicate elements from an array in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr#L1843&quot;&gt;Array#uniq&lt;/a&gt;.
I discussed a couple of optimizations the Crystal team used to implement &lt;code&gt;uniq&lt;/code&gt;
for small or empty arrays.&lt;/p&gt;
&lt;p&gt;But what about the general case? How does Crystal remove duplicate elements
from large arrays? If I remove the small array optimizations, the Crystal
implementation of &lt;code&gt;Array#uniq&lt;/code&gt; reads like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;uniq
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Convert the Array into a Hash and then ask for its values
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    to_lookup_hash.values
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;protected &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;to_lookup_hash
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    to_lookup_hash { &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;protected &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;to_lookup_hash&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: T &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;-&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;U) forall U
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    each_with_object(Hash(U, T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;o, h&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is &lt;em&gt;almost&lt;/em&gt; easy to read. Admittedly, I’m a Ruby developer, so the Ruby-like
syntax makes perfect sense to me. However, most developers will be able to
figure this out without much effort.&lt;/p&gt;
&lt;p&gt;Crystal identifies the unique elements of the array by converting it into a
“lookup hash:”&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;650&quot; src=&quot;https://patshaughnessy.net/assets/2021/11/6/lookup-hash.svg&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;As you know, hash keys are unique. By converting the array into a hash, Crystal
has quickly identified the unique elements of that array.&lt;/p&gt;
&lt;h2&gt;Converting An Array To A Hash At Runtime&lt;/h2&gt;
&lt;p&gt;But if you read carefully, you’ll see that Crystal converts the array to a hash
twice: once at compile time and then later again at runtime. Let’s look at the
second, runtime program first, working our way from the inside out.&lt;/p&gt;
&lt;p&gt;First, the &lt;code&gt;unless&lt;/code&gt; clause inside the loop checks whether the hash already
contains a given element. If the element isn’t already in the hash, Crystal
adds it:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is the crux of the unique algorithm. Crystal won’t insert a given key
value twice. (Although the &lt;code&gt;unless&lt;/code&gt; clause is technically unnecessary; saving a
repeated value would be harmless, overwriting the previous copy in the hash.)&lt;/p&gt;
&lt;p&gt;Looking up one line, we can see the &lt;code&gt;to_lookup_hash&lt;/code&gt; function accepts a block,
and calls it to calculate the a key value for each array element:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;And reading farther up, we can see another definition of &lt;code&gt;to_lookup_hash&lt;/code&gt; passes
in such a block:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#795da3;&quot;&gt;protected &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;to_lookup_hash
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  to_lookup_hash { &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem }
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Since the block &lt;code&gt;{ |elem| elem }&lt;/code&gt; just returns whatever was passed into it, the
keys and values of the lookup hash will be the same:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;275&quot; src=&quot;https://patshaughnessy.net/assets/2021/11/6/keys-and-values.svg&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;This block adds a bit of flexibility to the code. The Crystal team might want
to reuse this function someday with a different block and set of keys.&lt;/p&gt;
&lt;p&gt;Finally, let’s look at how Crystal iterates over the array:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;each_with_object(Hash(U, T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;o, h&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal calls &lt;code&gt;each_with_object&lt;/code&gt; on the array and provides a single argument:
&lt;code&gt;Hash(U, T).new&lt;/code&gt;. Here’s our first example of generic type syntax. I’ll come
back to that in a moment. For now, I can guess that &lt;code&gt;Hash(U, T).new&lt;/code&gt; creates a
new, empty hash.&lt;/p&gt;
&lt;p&gt;Next, &lt;code&gt;each_with_object&lt;/code&gt; loops over the receiver (the array), and calls the block
&lt;code&gt;do |o, h| … end&lt;/code&gt; for each element. It sets &lt;code&gt;o&lt;/code&gt; to each element’s value as it
iterates, and &lt;code&gt;h&lt;/code&gt; to the hash created with &lt;code&gt;Hash(U, T).new&lt;/code&gt;. As we saw above, the
block inserts each value &lt;code&gt;o&lt;/code&gt; into the hash &lt;code&gt;h&lt;/code&gt;, skipping duplicates.&lt;/p&gt;
&lt;p&gt;Finally, after the iteration completes, Crystal returns the values from the new
hash, a new array containing only the unique elements from the original array:`&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;to_lookup_hash.values&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Converting An Array To A Hash At Compile Time&lt;/h2&gt;
&lt;p&gt;But there’s more to this program than meets the eye. Crystal actually runs part
of this code, the generic type syntax, earlier at compile time. And, curiously,
that code also converts the array into a hash but in a different way. When the
Crystal team wrote &lt;code&gt;Array#uniq&lt;/code&gt;, they had to write two programs, not one!&lt;/p&gt;
&lt;p&gt;What exactly do I mean by “converting an array to a hash at compile time?”
How and why does this happen? And what’s the second program here?&lt;/p&gt;
&lt;p&gt;The answer has to do with the &lt;code&gt;Hash(U, T).new&lt;/code&gt; expression we read above. Crystal
needs to convert the type &lt;code&gt;Array(T)&lt;/code&gt; into the type &lt;code&gt;Hash(U, T)&lt;/code&gt;. Let’s step through
the second, type-level mirror program to find out how this works.&lt;/p&gt;
&lt;p&gt;You can imagine the Crystal compiler processing the generic type code like
this:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;550&quot; src=&quot;https://patshaughnessy.net/assets/2021/11/6/solved-puzzle.svg&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;The first line is actually the most important:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This line means the Crystal team is not implementing a simple array of
elements. Instead, they are implementing an array that must contain elements of
the same type. And here on this line they name that type in a generic way: the
type variable &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Specifying an array element type provides two important benefits: First, it is
a nice safety net for us, the developers using Crystal arrays. Crystal’s
compiler will prevent us from accidentally inserting elements from a different
or unexpected type into the array. And the best part is that Crystal will tell
us about our mistake at compile time, before our code ever runs and does any
harm with real data. It’s annoying and difficult to write a second compile-time
program using types, but the compiler might - and probably will - find some of
our mistakes and tell us before the program even runs.&lt;/p&gt;
&lt;p&gt;Second, because Crystal knows that all of the elements of the array have the
same type, it can emit more efficient code that takes advantage of this
knowledge. The machine language code the compiler produces can save and copy
array elements faster because it knows how much memory each element occupies.&lt;/p&gt;
&lt;p&gt;And by using generic type syntax to write &lt;code&gt;Array#uniq&lt;/code&gt;, the Crystal team gives us
these benefits regardless of what kind of elements we add to our arrays. The
Crystal compiler automatically maps the type we happen to choose in our code to
the variable &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, take a look at the &lt;code&gt;to_lookup_hash&lt;/code&gt; function declaration:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#795da3;&quot;&gt;protected &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;to_lookup_hash&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: T &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;-&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;U) forall U&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;What in the world does this mean? What is &lt;code&gt;forall U&lt;/code&gt; referring to?&lt;/p&gt;
&lt;p&gt;The first thing to note here is Crystal’s block parameter syntax: &lt;code&gt;&amp;amp; : T -&amp;gt; U&lt;/code&gt;.
Crystal has borrowed the &lt;code&gt;&amp;amp;&lt;/code&gt; character from Ruby to indicate the following
value is a block or closure, not a simple value. But in Crystal, the block
parameters and the block’s return value all must have types. And here in this
code those types are generic types: &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;. The arrow syntax tells us that the
block takes a single parameter of type &lt;code&gt;T&lt;/code&gt;, and returns a single value of type &lt;code&gt;U&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what do &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; mean? Where are they defined?&lt;/p&gt;
&lt;p&gt;This is our math puzzle for the day. Just like in a limit, integral or infinite
series from Calculus, this formula contains &lt;em&gt;bound and free variables&lt;/em&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp; : &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;T &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;-&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;U forall U&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Since the enclosing class statement above declared the class to be &lt;code&gt;Array(T)&lt;/code&gt;,
Crystal binds the &lt;code&gt;T&lt;/code&gt; type variable here to be the same type as above. In order
words, the type of values passed into this block must be the same as the type
of the elements in the array.&lt;/p&gt;
&lt;p&gt;But what about &lt;code&gt;U&lt;/code&gt;? What type is that?&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;forall U&lt;/code&gt; clause declares the U type to be a &lt;em&gt;free variable&lt;/em&gt;. That means
that &lt;code&gt;U&lt;/code&gt;, unlike the type &lt;code&gt;T&lt;/code&gt;, is not bound to any known type value. &lt;code&gt;forall&lt;/code&gt;
tells the Crystal compiler that the following code should apply equally well to
any type &lt;code&gt;U&lt;/code&gt;, “for all” possible types &lt;code&gt;U&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Crystal compiler solves this math puzzle using the &lt;code&gt;yield&lt;/code&gt; statement we saw
above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Here Crystal knows the value &lt;code&gt;o&lt;/code&gt; has a type of &lt;code&gt;T&lt;/code&gt;. How? Because Crystal knows
that all of the elements of the array have a type &lt;code&gt;T&lt;/code&gt;, (this is the &lt;code&gt;Array(T)&lt;/code&gt;
class) and Crystal knows the variable &lt;code&gt;o&lt;/code&gt; was set earlier to an array element
by &lt;code&gt;each_with_object&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, the Crystal compiler can determine that &lt;code&gt;U == T&lt;/code&gt;, that both types are the
same. How? When Crystal compiles the block’s code above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;to_lookup_hash { &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem }&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;…Crystal notices that the return value of the block is the same as the value
passed into the block, that &lt;code&gt;elem == elem&lt;/code&gt;. Then, the Crystal compiler maps
this return value to the block declaration: &lt;code&gt;&amp;amp; : T -&amp;gt; U&lt;/code&gt;. Because Crystal knows
&lt;code&gt;elem == elem&lt;/code&gt; in the block code, it deduces that the types of these values are
also the same, that &lt;code&gt;U == T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, let’s return to the line above that iterates over the array:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;each_with_object(Hash(U, T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;o, h&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Now the Crystal compiler can use the knowledge that types &lt;code&gt;U == T&lt;/code&gt; when it
creates the lookup hash. In Crystal when you create a hash, just as when you
create an array, you have to provide a type parameter for all the values. And
for hashes you also need to provide a type for the keys. &lt;code&gt;Hash(U, T).new&lt;/code&gt;
means: Create a new hash which has keys of type &lt;code&gt;U&lt;/code&gt; and values of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Armed with the knowledge that the keys of the lookup hash all have type &lt;code&gt;U&lt;/code&gt;, and
that &lt;code&gt;U == T&lt;/code&gt;, the Crystal compiler can emit the correct, optimized code for
finding and inserting hash values when it produces machine language
instructions for this passage:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal knows that both &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; have the same type &lt;code&gt;T&lt;/code&gt;, which allows the
&lt;code&gt;has_key?&lt;/code&gt; and &lt;code&gt;[]=&lt;/code&gt; methods to run quickly and correctly.&lt;/p&gt;
&lt;h2&gt;Are Generic Types Worth It?&lt;/h2&gt;
&lt;p&gt;It’s a good thing the Crystal compiler is good at solving math puzzles!
Crystal, like many other modern languages (Haskell, Swift, Rust, etc.) is able
to determine the actual, concrete types for variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;, and for
all values in your code, using &lt;em&gt;type inference&lt;/em&gt;. The Crystal compiler can
deduce what the type of each variable is based on the usage of that variable
and the context of the surrounding code.&lt;/p&gt;
&lt;p&gt;But the problem is that I, a user of the Crystal language, have to be good at
math puzzles also. As we’ve just seen, in order to write code using Crystal or
any language with a modern type system, I have to write my code twice: once to
solve the problem I actually want to solve, and a second time to prove to the
compiler that my code is consistent and mathematically correct at a type level.&lt;/p&gt;
&lt;p&gt;Are the added performance and added safety worth it? That depends entirely on
what code you are writing, how fast it needs to run, how many times and for how
long that code will be used - and most importantly, how much time you have to
solve math problems.&lt;/p&gt;
</content></entry><entry><title>To Learn a New Language, Read Its Standard Library</title><link href="https://patshaughnessy.net/2021/10/23/to-learn-a-new-language-read-its-standard-library" rel="alternate"></link><id href="https://patshaughnessy.net/2021/10/23/to-learn-a-new-language-read-its-standard-library" rel="alternate"></id><published>2021-10-23T00:00:00Z</published><updated>2021-10-23T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/10/23/chicken-little.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;If I was learning to read English as a foreign language,&lt;br/&gt; I would need something simple to get started.&lt;br/&gt;
  &lt;small&gt;(from The Remarkable Story of Chicken Little, 1840)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;The best way to learn a</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2021/10/23/chicken-little.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;If I was learning to read English as a foreign language,&lt;br/&gt; I would need something simple to get started.&lt;br/&gt;
  &lt;small&gt;(from The Remarkable Story of Chicken Little, 1840)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;The best way to learn a new programming language, just like a human language,
is from example. To learn how to write code you first need to read someone
else’s code. But who is the best person to learn from? Which code should we
read? Where should we look to find it?&lt;/p&gt;
&lt;p&gt;This year in my spare time I was learning about
&lt;a href=&quot;https://crystal-lang.org&quot;&gt;Crystal&lt;/a&gt;. I had played around with some simple
scripts, but I wanted to learn more. Then I stumbled on to Crystal’s &lt;a href=&quot;https://github.com/crystal-lang/crystal/tree/master/src&quot;&gt;standard
library&lt;/a&gt;. I was
relieved to see that Crystal’s core classes are implemented using Crystal
itself!&lt;/p&gt;
&lt;p&gt;Crystal’s standard library is clear, simple, concise and well documented.
Reading Crystal’s internal implementation of Array or Hash is like reading
a fairy tale in a children’s book. Anyone can understand it, even people
without a Ph.D. in Computer Science or systems programming experience.&lt;/p&gt;
&lt;div style=&quot;clear: left&quot;&gt;&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; There was a &lt;a href=&quot;https://news.ycombinator.com/item?id=28975453&quot;&gt;long discussion on Hacker
News&lt;/a&gt; about whether reading the
standard library really is a good idea for various different languages.&lt;/p&gt;
&lt;h2&gt;At First Glance, Crystal Is Ruby&lt;/h2&gt;
&lt;p&gt;At first glance, when I read Crystal’s &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr&quot;&gt;Array
implementation&lt;/a&gt;,
I thought I was reading a Ruby program:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;include &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Indexable&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;::Mutable(T)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;include &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Comparable(Array)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Size of an Array that we consider small to do linear scans or other optimizations.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;private &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SMALL_ARRAY_SIZE &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The size of this array.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The capacity of `@buffer`.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Note that, because `@buffer` moves on shift, the actual
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# capacity (the allocated memory) starts at `@buffer - @offset_to_buffer`.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The actual capacity is also given by the `remaining_capacity` internal method.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;capacity &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Offset to the buffer that was originally allocated, and which needs to
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# be reallocated on resize. On shift this value gets increased, together with
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# `@buffer`. To reach the root buffer you have to do `@buffer - @offset_to_buffer`,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# and this is also provided by the `root_buffer` internal method.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;offset_to_buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The buffer where elements start.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Pointer(T)&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;There are lots of familiar keywords, like &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;. I also
see Ruby’s &lt;code&gt;@&lt;/code&gt; character indicating an instance variable. This code is about 100x
easier to read vs. &lt;a href=&quot;https://github.com/ruby/ruby/blob/master/array.c&quot;&gt;Ruby’s own C implementation of
Array&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Along with the familiar Ruby-like syntax, notice the helpful comments. Even
though I’ve just started reading I can already make an educated guess at how
Crystal arrays function internally. I can see there’s a pointer to memory which
holds the array elements, and that the code keeps track of the capacity of this
memory along with the actual size of the array. Finally, reading the comment for
&lt;code&gt;offset_to_buffer&lt;/code&gt; I can imagine there are some optimizations related to adding
and removing elements. The comment is both helpful and intriguing.&lt;/p&gt;
&lt;p&gt;But I’m not reading Ruby code. There are important differences here: generic
type syntax and most importantly each of the instance variables is declared
with a static type known at compile time. How do I use static types in Crystal?
What types are available? What about the generic type parameter &lt;code&gt;T&lt;/code&gt;? Should I
use that in my own Crystal code? What other syntax differences vs. Ruby are
there?&lt;/p&gt;
&lt;p&gt;The best way to learn how to write Crystal code is simply to scroll down and
read one of the Array methods.&lt;/p&gt;
&lt;h2&gt;Array#uniq&lt;/h2&gt;
&lt;p&gt;Here’s how Crystal finds the unique elements of an array:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;uniq
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;dup
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Heuristic: for a small array it&amp;#39;s faster to do a linear scan
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# than creating a Hash to find out duplicates.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SMALL_ARRAY_SIZE
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Array(T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    each &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary.includes?(elem)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Convert the Array into a Hash and then ask for its values
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  to_lookup_hash.values
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The first three lines handle the trivial case of when an array is empty or
contains only one element:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;dup
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Obviously in this case, there are no duplicate elements and &lt;code&gt;Array#uniq&lt;/code&gt; should
simply return the original array. One important detail: Crystal uses &lt;code&gt;dup&lt;/code&gt; to
return a copy of the array. This reminds me that in Ruby &lt;code&gt;uniq&lt;/code&gt; returns a copy
of the receiver, while &lt;code&gt;uniq!&lt;/code&gt; mutates the receiver. My guess is that Crystal
implements Array methods in the same way…&lt;/p&gt;
&lt;p&gt;The second passage is an optimization:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# Heuristic: for a small array it&amp;#39;s faster to do a linear scan
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# than creating a Hash to find out duplicates.
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SMALL_ARRAY_SIZE
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Array(T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  each &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary.includes?(elem)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;For small arrays (16 or fewer elements) Crystal iterates over them and removes
duplicates using a simple algorithm. I’ll take a look at how that works in a
moment.&lt;/p&gt;
&lt;p&gt;The final line of code handles arrays with 17 or more elements:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;# Convert the Array into a Hash and then ask for its values
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;to_lookup_hash.values&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;As you might guess, Crystal removes duplicate values from larger arrays using a
hash. I'll dive into the details about how this works in my next post.&lt;/p&gt;
&lt;h2&gt;Arrays With 16 Or Fewer Elements&lt;/h2&gt;
&lt;p&gt;But first, let’s take a closer look at case #2 from above, when the array
contains 16 or fewer elements. First, Crystal creates a new, empty array called
ary:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Array(T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Note the generic type syntax &lt;code&gt;Array(T).new&lt;/code&gt;. This tells the Crystal compiler
that the new array, what will become the return value from &lt;code&gt;Array#uniq&lt;/code&gt;, will
only contain elements of the same type as the original array.&lt;/p&gt;
&lt;p&gt;Ruby developers will find the rest of this code easy to follow…&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;each &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary.includes?(elem)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal calls &lt;code&gt;each&lt;/code&gt; to iterate over all the elements in the receiver, the
array we are calling &lt;code&gt;uniq&lt;/code&gt; on. Then using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, Crystal appends each of the
original array’s elements to the new array, unless the new array already
contains a given element.&lt;/p&gt;
&lt;p&gt;Like Ruby, Crystal implements the &lt;code&gt;includes?&lt;/code&gt; method inside the &lt;code&gt;Enumerable&lt;/code&gt;
module. Crystal arrays are enumerable because of the &lt;code&gt;include Indexable::Mutable(T)&lt;/code&gt; statement we read above. (&lt;code&gt;Indexable::Mutable&lt;/code&gt; includes
&lt;code&gt;Indexable&lt;/code&gt; which includes &lt;code&gt;Enumerable&lt;/code&gt;). You can find Crystal’s implementation
of &lt;code&gt;includes?&lt;/code&gt; (not &lt;code&gt;include?&lt;/code&gt; as in Ruby) in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/enumerable.cr&quot;&gt;enumerable.cr&lt;/a&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;includes?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(obj) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Bool
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  any? { &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;e&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; e &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;==&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; obj }
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Here the &lt;code&gt;any?&lt;/code&gt; method calls the given block once for each element in the
array, and returns true if the block returns true for any of the elements. In
other words, this code searches the array in a linear fashion, one element at a
time. Crystal’s development team has decided that it’s faster to filter out
repeated elements from small arrays by repeatedly searching the array using
linear scans. Since there are never more than 16 elements, those scans won’t
take too much time.&lt;/p&gt;
&lt;h2&gt;Simple and Concise&lt;/h2&gt;
&lt;p&gt;You might be thinking: This is an incredibly simple algorithm; anyone could have
written this code! Why bother writing a blog post about this?&lt;/p&gt;
&lt;p&gt;That’s exactly my point: This is simple and concise code. I could have written
it - you could have also. There’s nothing superfluous, not an extra word here.
Just enough code to get the job done. And there’s no noise… no macros, no odd C
memory tricks, no weird bitwise mask operations. This is the kind of code I
need to read now when I’m learning how to use Crystal. As a side benefit, I
also get to learn how Crystal works internally.&lt;/p&gt;
&lt;p&gt;But what happens for longer arrays, with 100s or 1000s of elements? How does
Crystal remove duplicates from longer arrays efficiently? I'll take a look at
how that works in my next post.&lt;/p&gt;
</content></entry><entry><title>Downloading 100,000 Files Using Async Rust</title><link href="https://patshaughnessy.net/2020/1/20/downloading-100000-files-using-async-rust" rel="alternate"></link><id href="https://patshaughnessy.net/2020/1/20/downloading-100000-files-using-async-rust" rel="alternate"></id><published>2020-01-20T00:00:00Z</published><updated>2020-01-20T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/traffic-light.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust's new async/await feature makes it &lt;br/&gt;
easy to stop and start asynchronous tasks&lt;/i&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Red_and_green_traffic_signals,_Stamford_Road,_Singapore_-_20</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/traffic-light.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust's new async/await feature makes it &lt;br/&gt;
easy to stop and start asynchronous tasks&lt;/i&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Red_and_green_traffic_signals,_Stamford_Road,_Singapore_-_20111210.jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;Imagine if you had a text file containing thousands of URLs:&lt;/p&gt;
&lt;pre&gt;$ cat urls.txt
https://example.com/1.html
https://example.com/2.html
https://example.com/3.html

etc...

https://example.com/99999.html
https://example.com/100000.html&lt;/pre&gt;
&lt;p&gt;…and you needed to download all of those HTML pages efficiently. How would you
do it? Maybe a shell script using &lt;span class=&quot;code&quot;&gt;xargs&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;curl&lt;/span&gt;? Maybe a simple Golang program? Go’s powerful
concurrency features would work well for this.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;p&gt;Instead, I decided to try to use Rust. I’ve read a lot about safe concurrency
in Rust, but I’ve never tried it. I also wanted to learn what Rust’s new
“async/await” feature was all about. This seemed like the perfect task for
asynchronous Rust code.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TL/DR&lt;/em&gt;: &lt;a href=&quot;https://gist.github.com/patshaughnessy/27b1611e2c912346b929df97998d488d&quot;&gt;Here’s the
code&lt;/a&gt;.
The rest of this post will explain how it works.&lt;/p&gt;
&lt;h2&gt;Getting Started With Reqwest&lt;/h2&gt;
&lt;p&gt;There are many different Rust HTTP clients to choose from, and &lt;a href=&quot;https://medium.com/@shnatsel/smoke-testing-rust-http-clients-b8f2ee5db4e6&quot;&gt;apparently some
controversy&lt;/a&gt;
about which works best. Because I’m a Rust newbie, I decided simply to pick the most
popular: &lt;a href=&quot;https://github.com/seanmonstar/reqwest&quot;&gt;reqwest&lt;/a&gt;. Request is a high
level, easy to use HTTP client, written by &lt;a href=&quot;https://seanmonstar.com/&quot;&gt;Sean
McArthur&lt;/a&gt;. He just updated it to work with Tokio,
Rust’s new async/await engine, so this is the perfect time to try using it.
Here’s the example from the readme:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;use &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;std::collections::HashMap;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#[tokio::main]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://httpbin.org/ip&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .await&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .json::&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt;()
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .await&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:#?}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, resp);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(())
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This version downloads some JSON and parses it. Notice the new &lt;span
class=&quot;code&quot;&gt;async&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; keywords. The
main function is &lt;span class=&quot;code&quot;&gt;async&lt;/span&gt; - this means that the function
becomes part of a large state machine run by Tokio. When you mark a function
asynchronous, you can then call &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; inside it,
which will pause that function temporarily, allowing other asynchronous
functions to run on the same thread.&lt;/p&gt;
&lt;p&gt;I decided to modify this to print out the number of bytes downloaded instead; you could
easily change it to save the data to a file or do whatever you want.&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://httpbin.org/ip&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Ok(())&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is a two step process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;First I call &lt;span class=&quot;code&quot;&gt;get(path)&lt;/span&gt; to send the HTTP GET request. Then I use &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; to wait for
the request to finish and return a result.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Second, if the request was successful, I call &lt;span
  class=&quot;code&quot;&gt;resp.text()&lt;/span&gt; to get the contents of the response body. And
I wait again while that is loaded.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I handle the errors explicitly and always return a unit result &lt;span
class=&quot;code&quot;&gt;Ok(())&lt;/span&gt; because that makes the code below simpler
when I start downloading more than one page concurrently.&lt;/p&gt;
&lt;p&gt;Visually, I can draw the &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;text&lt;/span&gt; calls like this:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/get-and-text.png&quot;&gt;
&lt;p&gt;First I call &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and wait, then I call &lt;span
class=&quot;code&quot;&gt;text&lt;/span&gt; and wait.&lt;/p&gt;
&lt;p&gt;But what is asynchronous about this? This reads like normal, single threaded
code. I do one thing, then I do another.&lt;/p&gt;
&lt;h2&gt;Sending 3 Concurrent Requests&lt;/h2&gt;
&lt;p&gt;The magic happens when I have more than one request I want to make in parallel. Let’s use three hard coded path strings:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;vec![
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/1.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/2.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/3.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;To download the 3 HTML files in parallel, I spawn three Tokio “tasks” and wait
for them all to complete. (This requires adding the futures crate to
Cargo.toml, which implements &lt;span class=&quot;code&quot;&gt;join_all&lt;/span&gt;.)&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a7adba;&quot;&gt;// Iterate over the paths.
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; tasks: Vec&amp;lt;JoinHandle&amp;lt;Result&amp;lt;(), ()&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;vec![];
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Copy each path into a new string
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// that can be consumed/captured by the task closure
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path.clone();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Create a Tokio task for each path
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    tasks.push(tokio::spawn(async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;move &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(())
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }));
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Wait for them all to finish
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Started &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; tasks. Waiting...&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, tasks.len());
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;join_all(tasks).await;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Each Tokio task is a closure passed to the &lt;span
class=&quot;code&quot;&gt;tokio::spawn&lt;/span&gt; function, marked &lt;span class=&quot;code&quot;&gt;async
move&lt;/span&gt;. I create a copy of each path, using &lt;span
class=&quot;code&quot;&gt;path.clone()&lt;/span&gt;, so the closure has its own copy of the path
string with its own lifetime.&lt;/p&gt;
&lt;p&gt;The complex type annotation on the &lt;span class=&quot;code&quot;&gt;tasks&lt;/span&gt; array
indicates what each call to &lt;span class=&quot;code&quot;&gt;spawn&lt;/span&gt; returns: a &lt;span
class=&quot;code&quot;&gt;JoinHandle&lt;/span&gt; enclosing a &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt;. To
keep things simple, I handle all errors in the closure and just return &lt;span
class=&quot;code&quot;&gt;Ok(())&lt;/span&gt;.  This means each &lt;span
class=&quot;code&quot;&gt;JoinHandle&lt;/span&gt; contains a trivial result: &lt;span
class=&quot;code&quot;&gt;Result&amp;lt;(), ()&amp;gt;&lt;/span&gt;. I could have written the closure to return
some value and/or some error value instead.&lt;/p&gt;
&lt;p&gt;After the loop is finished and all three tasks have been spawned, I call &lt;span
class=&quot;code&quot;&gt;join_all(tasks).await&lt;/span&gt; to wait for them all to finish.&lt;/p&gt;
&lt;h2&gt;Asynchronous vs Multithreaded&lt;/h2&gt;
&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/traffic-light2.jpg&quot;&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Traffic_lights,_Zl%C3%ADn.JPG&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;At first glance, it looks like this code is spawning three different threads. I
even call a spawn function. A multithreaded download might look like this:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/multithreaded.png&quot;&gt;
&lt;p&gt;We have 3 paths, so we have 3 threads. Each thread calls &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and waits, and
then calls &lt;span class=&quot;code&quot;&gt;text&lt;/span&gt; and waits.&lt;/p&gt;
&lt;p&gt;However, Rust’s Tokio engine doesn’t work that way. Instead of launching an
entirely new thread for each task, it runs all three tasks on the same thread.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: Wesley Moore &lt;a href=&quot;https://twitter.com/wezm/status/1219734031857635329&quot;&gt;pointed out on
Twitter&lt;/a&gt; that: &amp;quot;Tokio
multiplexes m tasks into a pool of n threads so it’s able to use all available
cores. (M:N threading).&amp;quot; It looks like Tokio supports both a Basic (single
threaded) and Threaded (thread pool) Scheduler; see &lt;a href=&quot;https://docs.rs/tokio/0.2.10/tokio/runtime/index.html#threaded-scheduler&quot;&gt;the
docs&lt;/a&gt;
for more information.&lt;/p&gt;
&lt;p&gt;I imagine three tasks running on one thread like this:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/one-thread.png&quot;&gt;
&lt;p&gt;Each time I call &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt;, Rust stops one task and
starts another using the same thread. In fact, depending on how long it takes
for each task to complete, they might be run in a different order:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/different-order.png&quot;&gt;
&lt;p&gt;There’s no way to predict ahead of time what order the tasks will run it.
That’s why I needed to copy each path string above; each task needs it own copy
of the string with its own independent lifetime because it might be run at any
time.&lt;/p&gt;
&lt;p&gt;The only guarantee I have is that the &lt;span class=&quot;code&quot;&gt;join_all&lt;/span&gt; call
at the bottom will block until all of the tasks have finished; that is, until
all of the futures I pushed onto the tasks array have completed.&lt;/p&gt;
&lt;h2&gt;Sending 100,000 Concurrent Requests&lt;/h2&gt;
&lt;p&gt;I can scale this up to 100,000 requests by reading the URLs in from a file instead:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;read_lines&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(path: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;str&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) -&amp;gt; Result&amp;lt;Vec&amp;lt;String&amp;gt;, Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(path)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; reader &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;BufReader::new(file);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        reader.lines().filter_map(Result::ok).collect()
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    )
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#[tokio::main]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;	&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths: Vec&amp;lt;String&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;read_lines(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;urls.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;When I tried this out for the first time I was excited: How long would it take
to download 100,000 HTML pages simultaneously like this? Would it be 100,000x
faster than downloading one file? I typed &lt;span class=&quot;code&quot;&gt;cargo run
--release&lt;/span&gt; to build my code in release mode and get the best possible
performance out of Rust. Asynchronous code, zero cost abstractions, no garbage
collector, this was going to be great!&lt;/p&gt;
&lt;p&gt;Of course, it didn’t work.&lt;/p&gt;
&lt;p&gt;What happened? The problem is the web server can't handle so many concurrent network
connections. Using my thread/task diagram, launching all 100,000 tasks might
look like this:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/simultaneous.png&quot;&gt;
&lt;p&gt;I spawn 100,000 tasks all on to the same thread, and Tokio starts executing
them all. Each time my code above calls &lt;span
class=&quot;code&quot;&gt;get(&amp;amp;path).await&lt;/span&gt;, Tokio pauses that task and starts
another, which calls &lt;span class=&quot;code&quot;&gt;get(&amp;amp;path).await&lt;/span&gt; again, opening
yet another HTTP request. My laptop quickly runs out of network resources and
these tasks start to fail.&lt;/p&gt;
&lt;h2&gt;Sending a Buffered, Concurrent Stream of 100,000 Requests&lt;/h2&gt;
&lt;p&gt;Instead, I need to limit the number of concurrent Tokio tasks - the number of
concurrent HTTP requests. I need the diagram to look something like this:&lt;/p&gt;
&lt;img src=&quot;https://patshaughnessy.net/assets/2020/1/20/buffered.png&quot;&gt;
&lt;p&gt;After the first 8 tasks are started, the first 8 blue boxes on the left, Tokio
waits for at least one of them to complete before starting a 9th task. I
indicate this with the “max concurrency” arrow.&lt;/p&gt;
&lt;p&gt;Once one of the first 8 calls to &lt;span class=&quot;code&quot;&gt;reqwest::get&lt;/span&gt;
completes, Tokio is free to run a 9th task. The first &amp;quot;pop from buffer&amp;quot; arrow.
And once that 9th task or any other task completes, Tokio starts a 10th task,
etc., in this manner processing all 100,000 tasks 8 at a time.&lt;/p&gt;
&lt;p&gt;To achieve this, I can use &lt;span class=&quot;code&quot;&gt;StreamExt&lt;/span&gt; trait’s &lt;a
href=&quot;https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.5/futures/stream/trait.StreamExt.html#method.buffer_unordered&quot;&gt;&lt;span
class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt;&lt;/a&gt; function:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; fetches &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;futures::stream::iter(
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    paths.into_iter().map(|path| {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;move &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                            println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;})
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).buffer_unordered(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).collect::&amp;lt;Vec&amp;lt;()&amp;gt;&amp;gt;();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Waiting...&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;fetches.await;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;First I create an iterator which maps all of the paths to my closures, and passes
them to &lt;span class=&quot;code&quot;&gt;futures::stream::iter&lt;/span&gt;.
This will create a list of futures, each one executing my closure.&lt;/p&gt;
&lt;p&gt;At the bottom I call &lt;span class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; and pass in 8.  The
code in &lt;span class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; will execute up to 8 futures
from the stream concurrently, and then start to buffer the remaining futures.
As each task completes, each HTTP request in my example, &lt;span
class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; will pull another task out of its buffer
and execute it.&lt;/p&gt;
&lt;p&gt;This code will slowly but steadily iterate over the 100,000 URLs, downloading
them in parallel. Experimenting with this, it doesn’t seem to matter very much
exactly what level of concurrency I pick. I found the best performance when I
picked a concurrency of 50. Using 50 concurrent Tokio tasks, it took about 30
minutes to download all one hundred thousand HTML files.&lt;/p&gt;
&lt;p&gt;However, none of that matters. I’m not measuring the performance of Rust, Tokio
or Reqwest. These numbers have more to do with the web server and network
connection I’m using. The real performance here was my own developer
performance: With just a few lines of code I was able to write an asynchronous
I/O program that can scale as much as I would like. The &lt;span
class=&quot;code&quot;&gt;async&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; keywords make
this code easy to write and easy to read.&lt;/p&gt;
</content></entry></feed>