<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Pat Shaughnessy</title><id>http://patshaughnessy.net</id><updated>2021-11-29T19:25:48Z</updated><author><name>Pat Shaughnessy</name></author><entry><title>Find Your Language’s Primitives</title><link href="http://patshaughnessy.net/2021/11/29/find-your-languages-primitives" rel="alternate"></link><id href="http://patshaughnessy.net/2021/11/29/find-your-languages-primitives" rel="alternate"></id><published>2021-11-29T00:00:00Z</published><updated>2021-11-29T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: right; padding: 8px 0px 30px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/dig1.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;If you dig into your programming language's syntax, you might &lt;br/&gt;discover that it is capable of much more than you thought it was.
  &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Wikipedia defines “Language Primitive” &lt;a href=&quot;https://en.wikipedia.org/wik</summary><content type="html">&lt;div style=&quot;float: right; padding: 8px 0px 30px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/dig1.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;If you dig into your programming language's syntax, you might &lt;br/&gt;discover that it is capable of much more than you thought it was.
  &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Wikipedia defines “Language Primitive” &lt;a href=&quot;https://en.wikipedia.org/wiki/Language_primitive&quot;&gt;this
way&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
In computing, language primitives are the simplest elements available in a
programming language. A primitive is the smallest 'unit of processing'
available to a programmer of a given machine, or can be an atomic element of an
expression in a language.
&lt;/blockquote&gt;
&lt;p&gt;By looking at a language’s primitives, we can learn what kind of code will be
easy to write or impossible to express, and what types of problems the language
was intended to solve.  Whether you’ve been using a language for years, or just
now learning a new language for fun, take the time to find and learn about your
language’s primitives. You might discover something you never knew, and will
come away with a deeper understanding of how your programs work.&lt;/p&gt;
&lt;p&gt;As an example today, I’m going to look at how arrays work in three languages:
Ruby, Crystal and x86 Assembly Language.&lt;/p&gt;
&lt;h2&gt;Retrieving an Array Element In Ruby&lt;/h2&gt;
&lt;p&gt;In Ruby I can create an array and later access an element like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This code would be the same or almost the same in many other programming
languages. It just means: “find the second element of the array and print it to
stdout.”&lt;/p&gt;
&lt;p&gt;But how does this actually work? In Ruby, the &lt;span class=&quot;code&quot;&gt;Array&lt;/span&gt;
class and all of its methods are language primitives. This means array methods
like &lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;[]=&lt;/span&gt; cannot be
broken down into smaller pieces of Ruby code. As Wikipedia says, these methods
are the smallest unit of processing available to Ruby programmers working with
arrays.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/primitive1.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Ruby hides the details of how arrays actually work from us. To learn how Ruby
actually saves and retrieves values from an array, we would need to switch
languages and drop down a level of abstraction, and read the C implementation
in the Ruby source code:
&lt;a href=&quot;https://github.com/ruby/ruby/blob/master/array.c&quot;&gt;array.c&lt;/a&gt;. There’s nothing
wrong with this, of course. Ruby developers use arrays every day without any
trouble. But switching from Ruby to C makes understanding internal details much
more difficult.&lt;/p&gt;
&lt;h2&gt;Retrieving an Array Element In Crystal&lt;/h2&gt;
&lt;p&gt;This Fall I decided to learn more about &lt;a href=&quot;https://crystal-lang.org&quot;&gt;Crystal&lt;/a&gt;, a
statically typed language with syntax that resembles Ruby. I expected to find a
similar &lt;span class=&quot;code&quot;&gt;Array#[]&lt;/span&gt; primitive.  But surprisingly, I was
wrong!&lt;/p&gt;
&lt;p&gt;The same code from above also works in Crystal:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;arr &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12345&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;67890&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;In Crystal, arrays are not language primitives because the Crystal standard
library implements arrays using Crystal itself. The &lt;span
class=&quot;code&quot;&gt;Array#[]&lt;/span&gt; method is not the smallest unit of processing
available to Crystal programmers. Let’s dig into the details and divide up the
&lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; method into smaller and smaller pieces to see how
the Crystal team implemented it.&lt;/p&gt;
&lt;p&gt;Reading
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/indexable.cr#L56&quot;&gt;src/indexable.cr&lt;/a&gt;
in the Crystal standard library, here’s the implementation of &lt;span class=&quot;code&quot;&gt;Indexable#[]&lt;/span&gt;
which the array class uses when I call &lt;span class=&quot;code&quot;&gt;arr[1]&lt;/span&gt; above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Returns the element at the given *index*.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Negative indices can be used to start counting from the end of the array.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Raises `IndexError` if trying to access an element outside the array&amp;#39;s range.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[0]  # =&amp;gt; &amp;#39;a&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[2]  # =&amp;gt; &amp;#39;c&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[-1] # =&amp;gt; &amp;#39;c&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[-2] # =&amp;gt; &amp;#39;b&amp;#39;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[3]  # raises IndexError
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ary[-4] # raises IndexError
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;@[AlwaysInline]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;[]&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  fetch(index) { &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;raise &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;IndexError&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The Crystal team implemented &lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; using another method
called &lt;span class=&quot;code&quot;&gt;fetch&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Returns the element at the given *index*, if in bounds,
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# otherwise executes the given block with the index and returns its value.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# a = [:foo, :bar]
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# a.fetch(0) { :default_value }    # =&amp;gt; :foo
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# a.fetch(2) { :default_value }    # =&amp;gt; :default_value
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# a.fetch(2) { |index| index * 3 } # =&amp;gt; 6
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;fetch&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  index &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; check_index_out_of_bounds(index) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return yield &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;index
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  unsafe_fetch(index)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Neither the &lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; operator nor the &lt;span
class=&quot;code&quot;&gt;fetch&lt;/span&gt; method are language primitives. To find a language
primitive, I need to keep dividing the code up into smaller and smaller pieces,
until it can’t be divided any further. The same process a chemist would use to
break up some material into smaller and smaller molecules until they are left
with a set of atoms.&lt;/p&gt;
&lt;p&gt;Let’s continue by reading &lt;span class=&quot;code&quot;&gt;unsafe_fetch&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Returns the element at the given *index*, without doing any bounds check.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# `Indexable` makes sure to invoke this method with *index* in `0...size`,
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# so converting negative indices to positive ones is not needed here.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Clients never invoke this method directly. Instead, they access
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# elements with `#[](index)` and `#[]?(index)`.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# This method should only be directly invoked if you are absolutely
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# sure the index is in bounds, to avoid a bounds check for a small boost
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# of performance.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;abstract &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;unsafe_fetch&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;span class=&quot;code&quot;&gt;Indexable#unsafe_fetch&lt;/span&gt; is an abstract method, I
need to read how the &lt;span class=&quot;code&quot;&gt;Array&lt;/span&gt; class implements it back
in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr#L663&quot;&gt;src/array.cr&lt;/a&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;@[AlwaysInline]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;unsafe_fetch&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;T
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer[index]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;div style=&quot;float: right; padding: 8px 0px 30px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/dig2.jpg&quot;&gt;&lt;br/&gt;
	&lt;i&gt;&lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Digging_in_permafrost.jpg&quot;&gt;Nick Bonzey via Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;So far, I’ve drilled down through 3 levels of Crystal implementation:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/primitive2.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;But I haven’t found a primitive function yet. Let’s keep digging!&lt;/p&gt;
&lt;h2&gt;The Crystal Array Class&lt;/h2&gt;
&lt;p&gt;To learn more, I need to scroll up and read the beginning of the Crystal &lt;span
class=&quot;code&quot;&gt;Array&lt;/span&gt; class definition:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# An `Array` is an ordered, integer-indexed collection of objects of type T.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Array indexing starts at 0. A negative index is assumed to be
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# relative to the end of the array: -1 indicates the last element,
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# -2 is the next to last element, and so on.
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;etc...&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# An `Array` is implemented using an internal buffer of some capacity
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# and is reallocated when elements are pushed to it when more capacity
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# is needed. This is normally known as a [dynamic array](http://en.wikipedia.org/wiki/Dynamic_array).
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;etc...&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The buffer where elements start.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Pointer(T)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;I’ve deleted some of the comments and code for clarity. You can read the full,
original version in &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr&quot;&gt;src/array.cr.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now I get a sense of how the &lt;span class=&quot;code&quot;&gt;unsafe_fetch&lt;/span&gt; method
above works. Let’s repeat that again:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;unsafe_fetch&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(index : Int) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;T
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer[index]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal saves all of the elements in each array into a memory buffer called
&lt;span class=&quot;code&quot;&gt;@buffer&lt;/span&gt;. And when I access an element of the array
like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts arr[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal first checks that the array index (1 in this example) is valid, and
then loads the array element I want from the buffer using: &lt;span
class=&quot;code&quot;&gt;@buffer[1]&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;The Crystal Pointer Class&lt;/h2&gt;
&lt;p&gt;But how does &lt;span class=&quot;code&quot;&gt;@buffer[index]&lt;/span&gt; actually work? I haven’t learned anything yet! I’m
just going around in circles. So far all I’ve been able to find is that Crystal
implements &lt;span class=&quot;code&quot;&gt;Array#[]&lt;/span&gt; with a different &lt;span class=&quot;code&quot;&gt;[]&lt;/span&gt; operator, on a different class. What
type of object is &lt;span class=&quot;code&quot;&gt;@buffer&lt;/span&gt;? What does it do?&lt;/p&gt;
&lt;p&gt;Reading the array class declaration again more carefully, I can see that
&lt;span class=&quot;code&quot;&gt;@buffer&lt;/span&gt; is an instance of the &lt;span class=&quot;code&quot;&gt;Pointer&lt;/span&gt; class:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The buffer where elements start.
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Pointer(T)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Let’s read how Crystal implements &lt;span class=&quot;code&quot;&gt;Pointer#[]&lt;/span&gt; in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/pointer.cr#L107&quot;&gt;src/pointer.cr:&lt;/a&gt;&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Gets the value pointed at this pointer&amp;#39;s address plus `offset * sizeof(T)`.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr = Pointer.malloc(4) { |i| i + 10 }
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr[0] # =&amp;gt; 10
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr[1] # =&amp;gt; 11
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr[2] # =&amp;gt; 12
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr[3] # =&amp;gt; 13
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;[]&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(offset)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  (self &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; offset).value
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Reading this, I discovered the Crystal team has written a class that represents
pointers! Just like using a pointer in C, Crystal code can refer to and access
any memory location directly. Because the &lt;span class=&quot;code&quot;&gt;Pointer&lt;/span&gt;
class is part of the language, Crystal allows us to implement our own data
structures and algorithms in a very detailed manner, allocating and accessing
memory just like the Crystal team has while implementing arrays, hashes and
other classes.&lt;/p&gt;
&lt;p&gt;Now I’ve dug down through 4 levels of Crystal function calls, but I still
haven’t found a language primitive yet.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/primitive3.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;A Crystal Language Primitive&lt;/h2&gt;
&lt;p&gt;We still haven’t discovered how arrays actually work - how pointers actually
work. That is, reading this line of code above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(self &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; offset).value
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;…I understand the meaning and intent of pointer arithmetic, and how it’s used
by Crystal arrays, but I still don’t see how or where Crystal actually obtains
the array element referenced by a given pointer.&lt;/p&gt;
&lt;p&gt;Digging deeper, let’s read the &lt;span class=&quot;code&quot;&gt;Pointer#value&lt;/span&gt; method
to find out - this method’s implementation should tell me exactly how Crystal
obtains the value:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Gets the value pointed by this pointer.
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;#
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr = Pointer(Int32).malloc(4)
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr.value = 42
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ptr.value # =&amp;gt; 42
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# ```
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;@[Primitive(&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;:pointer_get&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;value&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; : T
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, this is a language primitive - it says “primitive” right there
above the method definition!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/primitive4.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Returning to Wikipedia’s definition of a language primitive, this is an atomic
element of an expression. The Crystal compiler knows not to try to compile this
code but to assume this behavior is part of the language. In fact, there is no
implementation for &lt;span class=&quot;code&quot;&gt;Pointer#value&lt;/span&gt; here at all: the
method is empty!&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;value&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; : T
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The empty &lt;span class=&quot;code&quot;&gt;value&lt;/span&gt; method above doesn’t tell us where
the value actually comes from, or how Crystal obtains it. To learn that, we
need to step down one level of abstraction - we need to use a lower level
language, not Crystal.&lt;/p&gt;
&lt;h2&gt;Retrieving an Array Element In x86 Assembly Language&lt;/h2&gt;
&lt;div style=&quot;float: right; padding: 18px 0px 30px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/cave.png&quot;&gt;&lt;br/&gt;
&lt;/div&gt;
&lt;p&gt;What lower level language should we use? Since the Crystal team used the &lt;a href=&quot;https://llvm.org&quot;&gt;Low
Level Virtual Machine (LLVM)&lt;/a&gt; project to implement their
compiler, I could look at LLVM’s low level instruction language. But since I’m
not familiar with that, or with how the Crystal compiler works, I decided to
jump down to the lowest level of abstraction available to me on my Intel Mac:
x86 Assembly Language.&lt;/p&gt;
&lt;p&gt;Here’s my Crystal program again:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
$ cat array_example.cr
arr = [12345, 67890]
puts arr[1]
&lt;/pre&gt;
&lt;p&gt;If I compile the program without running it, and then use the &lt;span
class=&quot;code&quot;&gt;llvm-objdump&lt;/span&gt; command, LLVM will give me a version of my
code converted into Intel x86 Assembly Language:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
$ crystal build array_example.cr
$ llvm-objdump -D array_example &gt; array_example.a
&lt;/pre&gt;
&lt;p&gt;Now by reading the assembly produced by the Crystal compiler and LLVM, I can
see how the &lt;span class=&quot;code&quot;&gt;Pointer#[]&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;Pointer#value&lt;/span&gt; methods actually work:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
0000000100089bb0 &lt;_*Pointer(Int32)@Pointer(T)#[]&lt;Int32&gt;:Int32&gt;:
100089bb0: 50                           pushq %rax
100089bb1: e8 0a 00 00 00               callq 0x100089bc0 &lt;_*Pointer(Int32)@Pointer(T)#+&lt;Int32&gt;:Pointer(Int32)&gt;
100089bb6: 8b 00                        movl  (%rax), %eax
100089bb8: 59                           popq  %rcx
100089bb9: c3                           retq

0000000100089bc0 &lt;_*Pointer(Int32)@Pointer(T)#+&lt;Int32&gt;:Pointer(Int32)&gt;:
100089bc0: 48 63 c6                     movslq  %esi, %rax
100089bc3: 48 c1 e0 02                  shlq  $2, %rax
100089bc7: 48 01 c7                     addq  %rax, %rdi
100089bca: 48 89 f8                     movq  %rdi, %rax
100089bcd: c3                           retq
&lt;/pre&gt;
&lt;p&gt;Assembly language is just another programming language like any other, but with
a different set of primitives. The primitives in this language are hardware
instructions that my laptop’s CPU can understand and execute directly:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/primitive5.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;I won’t pretend to understand all the details here, but if you’re curious about
what this code does - how my compiled Crystal program actually retrieves a
value from an array - here are a few highlights you can look for:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/29/assembly-table.svg&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;If you’d like to learn more about x86 assembly language, I wrote an article a
few years ago explaining some of the basics: &lt;a href=&quot;https://patshaughnessy.net/2016/11/26/learning-to-read-x86-assembly-language&quot;&gt;Learning to Read x86 Assembly
Language&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Understand the Primitives of the Language You Are Using&lt;/h2&gt;
&lt;p&gt;Why did I bother with this exercise? To make sure I deeply understand the
programming languages I’m using. Ruby hides much of its implementation in C, so
I didn’t learn much looking at the Ruby array primitives in this example. And
the primitive functions of assembly language are by definition the instructions
my CPU can execute directly. It’s always fun trying to identify and understand
machine level instructions!&lt;/p&gt;
&lt;p&gt;But Crystal surprised me - I expected to see a set of primitive array functions
like we have in Ruby, but I was wrong. Instead, I learned that Crystal supports
pointers, just like C or other low level languages do. I discovered that
Crystal, unlike Ruby, might be an appropriate choice for low level systems
programming tasks. And I was able to learn all of this, along with the array
implementation details, because the Crystal team implemented its standard
library in the same, target language: Crystal. All I had to do was make an
effort to read some code.&lt;/p&gt;
&lt;p&gt;Dive into details and find out what the language primitives are in your
favorite programming language. You might be surprised and discover that your
language is capable of much more than you thought it was.&lt;/p&gt;
</content></entry><entry><title>Generic Types: Adding Math Puzzles To Your Code</title><link href="http://patshaughnessy.net/2021/11/6/generic-types-adding-math-puzzles-to-your-code" rel="alternate"></link><id href="http://patshaughnessy.net/2021/11/6/generic-types-adding-math-puzzles-to-your-code" rel="alternate"></id><published>2021-11-06T00:00:00Z</published><updated>2021-11-06T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/6/formula.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;In this formula, x is the bound variable, a is&lt;br/&gt;the free variable and e is constant.&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Most modern, statically typed languages allow us to use generic types. We write
a function once with generic type syntax, and t</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 30px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2021/11/6/formula.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;In this formula, x is the bound variable, a is&lt;br/&gt;the free variable and e is constant.&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Most modern, statically typed languages allow us to use generic types. We write
a function once with generic type syntax, and then the compiler can apply the
same code over and over again to different actual, concrete types. Hence the
name &lt;em&gt;generic&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This is a powerful language feature, but generic code is often confusing and
hard to read. For me, generic code resembles something from my high school
algebra textbook. I see small math puzzles sprinkled around my computer
program. Why do this? Why add math problems to your code? Computer programming
is already hard enough; why make it even more complicated?&lt;/p&gt;
&lt;p&gt;Generic types allow us to get the best of both words: the safety and
performance of static types, with the flexibility and simplicity of a dynamic,
typeless language.&lt;/p&gt;
&lt;p&gt;But this comes at a steep price: Using generic types force you to write two
programs, in a sense. Your normal code for runtime, and a second, parallel
type-specific program that runs at compile time. To see what I mean, let’s take
an example from the &lt;a href=&quot;https://github.com/crystal-lang/crystal/tree/master/src&quot;&gt;Crystal standard
library&lt;/a&gt; and explore
how the Crystal team used generic type syntax to implement their array class.&lt;/p&gt;
&lt;h2&gt;Array#uniq in Crystal&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://patshaughnessy.net/2021/10/23/to-learn-a-new-language-read-its-standard-library&quot;&gt;Last
time&lt;/a&gt;
I looked at the Crystal standard library, specifically at how Crystal removes
duplicate elements from an array in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr#L1843&quot;&gt;Array#uniq&lt;/a&gt;.
I discussed a couple of optimizations the Crystal team used to implement &lt;code&gt;uniq&lt;/code&gt;
for small or empty arrays.&lt;/p&gt;
&lt;p&gt;But what about the general case? How does Crystal remove duplicate elements
from large arrays? If I remove the small array optimizations, the Crystal
implementation of &lt;code&gt;Array#uniq&lt;/code&gt; reads like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;uniq
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Convert the Array into a Hash and then ask for its values
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    to_lookup_hash.values
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;protected &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;to_lookup_hash
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    to_lookup_hash { &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;protected &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;to_lookup_hash&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: T &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;-&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;U) forall U
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    each_with_object(Hash(U, T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;o, h&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is &lt;em&gt;almost&lt;/em&gt; easy to read. Admittedly, I’m a Ruby developer, so the Ruby-like
syntax makes perfect sense to me. However, most developers will be able to
figure this out without much effort.&lt;/p&gt;
&lt;p&gt;Crystal identifies the unique elements of the array by converting it into a
“lookup hash:”&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;650&quot; src=&quot;http://patshaughnessy.net/assets/2021/11/6/lookup-hash.svg&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;As you know, hash keys are unique. By converting the array into a hash, Crystal
has quickly identified the unique elements of that array.&lt;/p&gt;
&lt;h2&gt;Converting An Array To A Hash At Runtime&lt;/h2&gt;
&lt;p&gt;But if you read carefully, you’ll see that Crystal converts the array to a hash
twice: once at compile time and then later again at runtime. Let’s look at the
second, runtime program first, working our way from the inside out.&lt;/p&gt;
&lt;p&gt;First, the &lt;code&gt;unless&lt;/code&gt; clause inside the loop checks whether the hash already
contains a given element. If the element isn’t already in the hash, Crystal
adds it:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is the crux of the unique algorithm. Crystal won’t insert a given key
value twice. (Although the &lt;code&gt;unless&lt;/code&gt; clause is technically unnecessary; saving a
repeated value would be harmless, overwriting the previous copy in the hash.)&lt;/p&gt;
&lt;p&gt;Looking up one line, we can see the &lt;code&gt;to_lookup_hash&lt;/code&gt; function accepts a block,
and calls it to calculate the a key value for each array element:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;And reading farther up, we can see another definition of &lt;code&gt;to_lookup_hash&lt;/code&gt; passes
in such a block:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;protected &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;to_lookup_hash
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  to_lookup_hash { &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem }
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Since the block &lt;code&gt;{ |elem| elem }&lt;/code&gt; just returns whatever was passed into it, the
keys and values of the lookup hash will be the same:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;275&quot; src=&quot;http://patshaughnessy.net/assets/2021/11/6/keys-and-values.svg&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;This block adds a bit of flexibility to the code. The Crystal team might want
to reuse this function someday with a different block and set of keys.&lt;/p&gt;
&lt;p&gt;Finally, let’s look at how Crystal iterates over the array:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;each_with_object(Hash(U, T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;o, h&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal calls &lt;code&gt;each_with_object&lt;/code&gt; on the array and provides a single argument:
&lt;code&gt;Hash(U, T).new&lt;/code&gt;. Here’s our first example of generic type syntax. I’ll come
back to that in a moment. For now, I can guess that &lt;code&gt;Hash(U, T).new&lt;/code&gt; creates a
new, empty hash.&lt;/p&gt;
&lt;p&gt;Next, &lt;code&gt;each_with_object&lt;/code&gt; loops over the receiver (the array), and calls the block
&lt;code&gt;do |o, h| … end&lt;/code&gt; for each element. It sets &lt;code&gt;o&lt;/code&gt; to each element’s value as it
iterates, and &lt;code&gt;h&lt;/code&gt; to the hash created with &lt;code&gt;Hash(U, T).new&lt;/code&gt;. As we saw above, the
block inserts each value &lt;code&gt;o&lt;/code&gt; into the hash &lt;code&gt;h&lt;/code&gt;, skipping duplicates.&lt;/p&gt;
&lt;p&gt;Finally, after the iteration completes, Crystal returns the values from the new
hash, a new array containing only the unique elements from the original array:`&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;to_lookup_hash.values
&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Converting An Array To A Hash At Compile Time&lt;/h2&gt;
&lt;p&gt;But there’s more to this program than meets the eye. Crystal actually runs part
of this code, the generic type syntax, earlier at compile time. And, curiously,
that code also converts the array into a hash but in a different way. When the
Crystal team wrote &lt;code&gt;Array#uniq&lt;/code&gt;, they had to write two programs, not one!&lt;/p&gt;
&lt;p&gt;What exactly do I mean by “converting an array to a hash at compile time?”
How and why does this happen? And what’s the second program here?&lt;/p&gt;
&lt;p&gt;The answer has to do with the &lt;code&gt;Hash(U, T).new&lt;/code&gt; expression we read above. Crystal
needs to convert the type &lt;code&gt;Array(T)&lt;/code&gt; into the type &lt;code&gt;Hash(U, T)&lt;/code&gt;. Let’s step through
the second, type-level mirror program to find out how this works.&lt;/p&gt;
&lt;p&gt;You can imagine the Crystal compiler processing the generic type code like
this:&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;550&quot; src=&quot;http://patshaughnessy.net/assets/2021/11/6/solved-puzzle.svg&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;The first line is actually the most important:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This line means the Crystal team is not implementing a simple array of
elements. Instead, they are implementing an array that must contain elements of
the same type. And here on this line they name that type in a generic way: the
type variable &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Specifying an array element type provides two important benefits: First, it is
a nice safety net for us, the developers using Crystal arrays. Crystal’s
compiler will prevent us from accidentally inserting elements from a different
or unexpected type into the array. And the best part is that Crystal will tell
us about our mistake at compile time, before our code ever runs and does any
harm with real data. It’s annoying and difficult to write a second compile-time
program using types, but the compiler might - and probably will - find some of
our mistakes and tell us before the program even runs.&lt;/p&gt;
&lt;p&gt;Second, because Crystal knows that all of the elements of the array have the
same type, it can emit more efficient code that takes advantage of this
knowledge. The machine language code the compiler produces can save and copy
array elements faster because it knows how much memory each element occupies.&lt;/p&gt;
&lt;p&gt;And by using generic type syntax to write &lt;code&gt;Array#uniq&lt;/code&gt;, the Crystal team gives us
these benefits regardless of what kind of elements we add to our arrays. The
Crystal compiler automatically maps the type we happen to choose in our code to
the variable &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, take a look at the &lt;code&gt;to_lookup_hash&lt;/code&gt; function declaration:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;protected &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;to_lookup_hash&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: T &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;-&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;U) forall U
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;What in the world does this mean? What is &lt;code&gt;forall U&lt;/code&gt; referring to?&lt;/p&gt;
&lt;p&gt;The first thing to note here is Crystal’s block parameter syntax: &lt;code&gt;&amp;amp; : T -&amp;gt; U&lt;/code&gt;.
Crystal has borrowed the &lt;code&gt;&amp;amp;&lt;/code&gt; character from Ruby to indicate the following
value is a block or closure, not a simple value. But in Crystal, the block
parameters and the block’s return value all must have types. And here in this
code those types are generic types: &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;. The arrow syntax tells us that the
block takes a single parameter of type &lt;code&gt;T&lt;/code&gt;, and returns a single value of type &lt;code&gt;U&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what do &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; mean? Where are they defined?&lt;/p&gt;
&lt;p&gt;This is our math puzzle for the day. Just like in a limit, integral or infinite
series from Calculus, this formula contains &lt;em&gt;bound and free variables&lt;/em&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp; : &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;T &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;-&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;U forall U
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Since the enclosing class statement above declared the class to be &lt;code&gt;Array(T)&lt;/code&gt;,
Crystal binds the &lt;code&gt;T&lt;/code&gt; type variable here to be the same type as above. In order
words, the type of values passed into this block must be the same as the type
of the elements in the array.&lt;/p&gt;
&lt;p&gt;But what about &lt;code&gt;U&lt;/code&gt;? What type is that?&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;forall U&lt;/code&gt; clause declares the U type to be a &lt;em&gt;free variable&lt;/em&gt;. That means
that &lt;code&gt;U&lt;/code&gt;, unlike the type &lt;code&gt;T&lt;/code&gt;, is not bound to any known type value. &lt;code&gt;forall&lt;/code&gt;
tells the Crystal compiler that the following code should apply equally well to
any type &lt;code&gt;U&lt;/code&gt;, “for all” possible types &lt;code&gt;U&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Crystal compiler solves this math puzzle using the &lt;code&gt;yield&lt;/code&gt; statement we saw
above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Here Crystal knows the value &lt;code&gt;o&lt;/code&gt; has a type of &lt;code&gt;T&lt;/code&gt;. How? Because Crystal knows
that all of the elements of the array have a type &lt;code&gt;T&lt;/code&gt;, (this is the &lt;code&gt;Array(T)&lt;/code&gt;
class) and Crystal knows the variable &lt;code&gt;o&lt;/code&gt; was set earlier to an array element
by &lt;code&gt;each_with_object&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, the Crystal compiler can determine that &lt;code&gt;U == T&lt;/code&gt;, that both types are the
same. How? When Crystal compiles the block’s code above:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;to_lookup_hash { &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem }
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;…Crystal notices that the return value of the block is the same as the value
passed into the block, that &lt;code&gt;elem == elem&lt;/code&gt;. Then, the Crystal compiler maps
this return value to the block declaration: &lt;code&gt;&amp;amp; : T -&amp;gt; U&lt;/code&gt;. Because Crystal knows
&lt;code&gt;elem == elem&lt;/code&gt; in the block code, it deduces that the types of these values are
also the same, that &lt;code&gt;U == T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, let’s return to the line above that iterates over the array:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;each_with_object(Hash(U, T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;o, h&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Now the Crystal compiler can use the knowledge that types &lt;code&gt;U == T&lt;/code&gt; when it
creates the lookup hash. In Crystal when you create a hash, just as when you
create an array, you have to provide a type parameter for all the values. And
for hashes you also need to provide a type for the keys. &lt;code&gt;Hash(U, T).new&lt;/code&gt;
means: Create a new hash which has keys of type &lt;code&gt;U&lt;/code&gt; and values of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Armed with the knowledge that the keys of the lookup hash all have type &lt;code&gt;U&lt;/code&gt;, and
that &lt;code&gt;U == T&lt;/code&gt;, the Crystal compiler can emit the correct, optimized code for
finding and inserting hash values when it produces machine language
instructions for this passage:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;key &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;yield&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; h.has_key?(key)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  h[key] &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; o
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal knows that both &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; have the same type &lt;code&gt;T&lt;/code&gt;, which allows the
&lt;code&gt;has_key?&lt;/code&gt; and &lt;code&gt;[]=&lt;/code&gt; methods to run quickly and correctly.&lt;/p&gt;
&lt;h2&gt;Are Generic Types Worth It?&lt;/h2&gt;
&lt;p&gt;It’s a good thing the Crystal compiler is good at solving math puzzles!
Crystal, like many other modern languages (Haskell, Swift, Rust, etc.) is able
to determine the actual, concrete types for variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;, and for
all values in your code, using &lt;em&gt;type inference&lt;/em&gt;. The Crystal compiler can
deduce what the type of each variable is based on the usage of that variable
and the context of the surrounding code.&lt;/p&gt;
&lt;p&gt;But the problem is that I, a user of the Crystal language, have to be good at
math puzzles also. As we’ve just seen, in order to write code using Crystal or
any language with a modern type system, I have to write my code twice: once to
solve the problem I actually want to solve, and a second time to prove to the
compiler that my code is consistent and mathematically correct at a type level.&lt;/p&gt;
&lt;p&gt;Are the added performance and added safety worth it? That depends entirely on
what code you are writing, how fast it needs to run, how many times and for how
long that code will be used - and most importantly, how much time you have to
solve math problems.&lt;/p&gt;
</content></entry><entry><title>To Learn a New Language, Read Its Standard Library</title><link href="http://patshaughnessy.net/2021/10/23/to-learn-a-new-language-read-its-standard-library" rel="alternate"></link><id href="http://patshaughnessy.net/2021/10/23/to-learn-a-new-language-read-its-standard-library" rel="alternate"></id><published>2021-10-23T00:00:00Z</published><updated>2021-10-23T00:00:00Z</updated><category>Crystal</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2021/10/23/chicken-little.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;If I was learning to read English as a foreign language,&lt;br/&gt; I would need something simple to get started.&lt;br/&gt;
  &lt;small&gt;(from The Remarkable Story of Chicken Little, 1840)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;The best way to learn a </summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2021/10/23/chicken-little.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;If I was learning to read English as a foreign language,&lt;br/&gt; I would need something simple to get started.&lt;br/&gt;
  &lt;small&gt;(from The Remarkable Story of Chicken Little, 1840)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;The best way to learn a new programming language, just like a human language,
is from example. To learn how to write code you first need to read someone
else’s code. But who is the best person to learn from? Which code should we
read? Where should we look to find it?&lt;/p&gt;
&lt;p&gt;This year in my spare time I was learning about
&lt;a href=&quot;https://crystal-lang.org&quot;&gt;Crystal&lt;/a&gt;. I had played around with some simple
scripts, but I wanted to learn more. Then I stumbled on to Crystal’s &lt;a href=&quot;https://github.com/crystal-lang/crystal/tree/master/src&quot;&gt;standard
library&lt;/a&gt;. I was
relieved to see that Crystal’s core classes are implemented using Crystal
itself!&lt;/p&gt;
&lt;p&gt;Crystal’s standard library is clear, simple, concise and well documented.
Reading Crystal’s internal implementation of Array or Hash is like reading
a fairy tale in a children’s book. Anyone can understand it, even people
without a Ph.D. in Computer Science or systems programming experience.&lt;/p&gt;
&lt;div style=&quot;clear: left&quot;&gt;&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; There was a &lt;a href=&quot;https://news.ycombinator.com/item?id=28975453&quot;&gt;long discussion on Hacker
News&lt;/a&gt; about whether reading the
standard library really is a good idea for various different languages.&lt;/p&gt;
&lt;h2&gt;At First Glance, Crystal Is Ruby&lt;/h2&gt;
&lt;p&gt;At first glance, when I read Crystal’s &lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/array.cr&quot;&gt;Array
implementation&lt;/a&gt;,
I thought I was reading a Ruby program:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;class &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Array&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(T)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;include &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Indexable&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;::Mutable(T)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;include &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Comparable(Array)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Size of an Array that we consider small to do linear scans or other optimizations.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;private &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SMALL_ARRAY_SIZE &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The size of this array.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The capacity of `@buffer`.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Note that, because `@buffer` moves on shift, the actual
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# capacity (the allocated memory) starts at `@buffer - @offset_to_buffer`.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The actual capacity is also given by the `remaining_capacity` internal method.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;capacity &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Offset to the buffer that was originally allocated, and which needs to
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# be reallocated on resize. On shift this value gets increased, together with
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# `@buffer`. To reach the root buffer you have to do `@buffer - @offset_to_buffer`,
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# and this is also provided by the `root_buffer` internal method.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;offset_to_buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Int32 &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# The buffer where elements start.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;buffer &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Pointer(T)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;There are lots of familiar keywords, like &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt;. I also
see Ruby’s &lt;code&gt;@&lt;/code&gt; character indicating an instance variable. This code is about 100x
easier to read vs. &lt;a href=&quot;https://github.com/ruby/ruby/blob/master/array.c&quot;&gt;Ruby’s own C implementation of
Array&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Along with the familiar Ruby-like syntax, notice the helpful comments. Even
though I’ve just started reading I can already make an educated guess at how
Crystal arrays function internally. I can see there’s a pointer to memory which
holds the array elements, and that the code keeps track of the capacity of this
memory along with the actual size of the array. Finally, reading the comment for
&lt;code&gt;offset_to_buffer&lt;/code&gt; I can imagine there are some optimizations related to adding
and removing elements. The comment is both helpful and intriguing.&lt;/p&gt;
&lt;p&gt;But I’m not reading Ruby code. There are important differences here: generic
type syntax and most importantly each of the instance variables is declared
with a static type known at compile time. How do I use static types in Crystal?
What types are available? What about the generic type parameter &lt;code&gt;T&lt;/code&gt;? Should I
use that in my own Crystal code? What other syntax differences vs. Ruby are
there?&lt;/p&gt;
&lt;p&gt;The best way to learn how to write Crystal code is simply to scroll down and
read one of the Array methods.&lt;/p&gt;
&lt;h2&gt;Array#uniq&lt;/h2&gt;
&lt;p&gt;Here’s how Crystal finds the unique elements of an array:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;uniq
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;dup
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Heuristic: for a small array it&amp;#39;s faster to do a linear scan
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# than creating a Hash to find out duplicates.
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SMALL_ARRAY_SIZE
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Array(T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    each &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary.includes?(elem)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Convert the Array into a Hash and then ask for its values
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  to_lookup_hash.values
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The first three lines handle the trivial case of when an array is empty or
contains only one element:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;= &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;dup
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Obviously in this case, there are no duplicate elements and &lt;code&gt;Array#uniq&lt;/code&gt; should
simply return the original array. One important detail: Crystal uses &lt;code&gt;dup&lt;/code&gt; to
return a copy of the array. This reminds me that in Ruby &lt;code&gt;uniq&lt;/code&gt; returns a copy
of the receiver, while &lt;code&gt;uniq!&lt;/code&gt; mutates the receiver. My guess is that Crystal
implements Array methods in the same way…&lt;/p&gt;
&lt;p&gt;The second passage is an optimization:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Heuristic: for a small array it&amp;#39;s faster to do a linear scan
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# than creating a Hash to find out duplicates.
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SMALL_ARRAY_SIZE
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Array(T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  each &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary.includes?(elem)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;For small arrays (16 or fewer elements) Crystal iterates over them and removes
duplicates using a simple algorithm. I’ll take a look at how that works in a
moment.&lt;/p&gt;
&lt;p&gt;The final line of code handles arrays with 17 or more elements:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;# Convert the Array into a Hash and then ask for its values
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;to_lookup_hash.values
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;As you might guess, Crystal removes duplicate values from larger arrays using a
hash. I'll dive into the details about how this works in my next post.&lt;/p&gt;
&lt;h2&gt;Arrays With 16 Or Fewer Elements&lt;/h2&gt;
&lt;p&gt;But first, let’s take a closer look at case #2 from above, when the array
contains 16 or fewer elements. First, Crystal creates a new, empty array called
ary:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Array(T).&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Note the generic type syntax &lt;code&gt;Array(T).new&lt;/code&gt;. This tells the Crystal compiler
that the new array, what will become the return value from &lt;code&gt;Array#uniq&lt;/code&gt;, will
only contain elements of the same type as the original array.&lt;/p&gt;
&lt;p&gt;Ruby developers will find the rest of this code easy to follow…&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;each &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;elem&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  ary &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; elem &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;unless&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; ary.includes?(elem)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Crystal calls &lt;code&gt;each&lt;/code&gt; to iterate over all the elements in the receiver, the
array we are calling &lt;code&gt;uniq&lt;/code&gt; on. Then using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, Crystal appends each of the
original array’s elements to the new array, unless the new array already
contains a given element.&lt;/p&gt;
&lt;p&gt;Like Ruby, Crystal implements the &lt;code&gt;includes?&lt;/code&gt; method inside the &lt;code&gt;Enumerable&lt;/code&gt;
module. Crystal arrays are enumerable because of the &lt;code&gt;include Indexable::Mutable(T)&lt;/code&gt; statement we read above. (&lt;code&gt;Indexable::Mutable&lt;/code&gt; includes
&lt;code&gt;Indexable&lt;/code&gt; which includes &lt;code&gt;Enumerable&lt;/code&gt;). You can find Crystal’s implementation
of &lt;code&gt;includes?&lt;/code&gt; (not &lt;code&gt;include?&lt;/code&gt; as in Ruby) in
&lt;a href=&quot;https://github.com/crystal-lang/crystal/blob/master/src/enumerable.cr&quot;&gt;enumerable.cr&lt;/a&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;includes?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(obj) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Bool
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  any? { &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;e&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; e &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;==&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; obj }
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Here the &lt;code&gt;any?&lt;/code&gt; method calls the given block once for each element in the
array, and returns true if the block returns true for any of the elements. In
other words, this code searches the array in a linear fashion, one element at a
time. Crystal’s development team has decided that it’s faster to filter out
repeated elements from small arrays by repeatedly searching the array using
linear scans. Since there are never more than 16 elements, those scans won’t
take too much time.&lt;/p&gt;
&lt;h2&gt;Simple and Concise&lt;/h2&gt;
&lt;p&gt;You might be thinking: This is an incredibly simple algorithm; anyone could have
written this code! Why bother writing a blog post about this?&lt;/p&gt;
&lt;p&gt;That’s exactly my point: This is simple and concise code. I could have written
it - you could have also. There’s nothing superfluous, not an extra word here.
Just enough code to get the job done. And there’s no noise… no macros, no odd C
memory tricks, no weird bitwise mask operations. This is the kind of code I
need to read now when I’m learning how to use Crystal. As a side benefit, I
also get to learn how Crystal works internally.&lt;/p&gt;
&lt;p&gt;But what happens for longer arrays, with 100s or 1000s of elements? How does
Crystal remove duplicates from longer arrays efficiently? I'll take a look at
how that works in my next post.&lt;/p&gt;
</content></entry><entry><title>Downloading 100,000 Files Using Async Rust</title><link href="http://patshaughnessy.net/2020/1/20/downloading-100000-files-using-async-rust" rel="alternate"></link><id href="http://patshaughnessy.net/2020/1/20/downloading-100000-files-using-async-rust" rel="alternate"></id><published>2020-01-20T00:00:00Z</published><updated>2020-01-20T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/traffic-light.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust's new async/await feature makes it &lt;br/&gt;
easy to stop and start asynchronous tasks&lt;/i&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Red_and_green_traffic_signals,_Stamford_Road,_Singapore_-_201</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/traffic-light.jpg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust's new async/await feature makes it &lt;br/&gt;
easy to stop and start asynchronous tasks&lt;/i&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Red_and_green_traffic_signals,_Stamford_Road,_Singapore_-_20111210.jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;Imagine if you had a text file containing thousands of URLs:&lt;/p&gt;
&lt;pre&gt;
$ cat urls.txt
https://example.com/1.html
https://example.com/2.html
https://example.com/3.html

etc...

https://example.com/99999.html
https://example.com/100000.html
&lt;/pre&gt;
&lt;p&gt;…and you needed to download all of those HTML pages efficiently. How would you
do it? Maybe a shell script using &lt;span class=&quot;code&quot;&gt;xargs&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;curl&lt;/span&gt;? Maybe a simple Golang program? Go’s powerful
concurrency features would work well for this.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;p&gt;Instead, I decided to try to use Rust. I’ve read a lot about safe concurrency
in Rust, but I’ve never tried it. I also wanted to learn what Rust’s new
“async/await” feature was all about. This seemed like the perfect task for
asynchronous Rust code.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;TL/DR&lt;/em&gt;: &lt;a href=&quot;https://gist.github.com/patshaughnessy/27b1611e2c912346b929df97998d488d&quot;&gt;Here’s the
code&lt;/a&gt;.
The rest of this post will explain how it works.&lt;/p&gt;
&lt;h2&gt;Getting Started With Reqwest&lt;/h2&gt;
&lt;p&gt;There are many different Rust HTTP clients to choose from, and &lt;a href=&quot;https://medium.com/@shnatsel/smoke-testing-rust-http-clients-b8f2ee5db4e6&quot;&gt;apparently some
controversy&lt;/a&gt;
about which works best. Because I’m a Rust newbie, I decided simply to pick the most
popular: &lt;a href=&quot;https://github.com/seanmonstar/reqwest&quot;&gt;reqwest&lt;/a&gt;. Request is a high
level, easy to use HTTP client, written by &lt;a href=&quot;https://seanmonstar.com/&quot;&gt;Sean
McArthur&lt;/a&gt;. He just updated it to work with Tokio,
Rust’s new async/await engine, so this is the perfect time to try using it.
Here’s the example from the readme:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;use &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;std::collections::HashMap;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#[tokio::main]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://httpbin.org/ip&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .await&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .json::&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt;()
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        .await&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:#?}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, resp);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(())
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This version downloads some JSON and parses it. Notice the new &lt;span
class=&quot;code&quot;&gt;async&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; keywords. The
main function is &lt;span class=&quot;code&quot;&gt;async&lt;/span&gt; - this means that the function
becomes part of a large state machine run by Tokio. When you mark a function
asynchronous, you can then call &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; inside it,
which will pause that function temporarily, allowing other asynchronous
functions to run on the same thread.&lt;/p&gt;
&lt;p&gt;I decided to modify this to print out the number of bytes downloaded instead; you could
easily change it to save the data to a file or do whatever you want.&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://httpbin.org/ip&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Ok(())
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is a two step process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;First I call &lt;span class=&quot;code&quot;&gt;get(path)&lt;/span&gt; to send the HTTP GET request. Then I use &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; to wait for
the request to finish and return a result.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Second, if the request was successful, I call &lt;span
  class=&quot;code&quot;&gt;resp.text()&lt;/span&gt; to get the contents of the response body. And
I wait again while that is loaded.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I handle the errors explicitly and always return a unit result &lt;span
class=&quot;code&quot;&gt;Ok(())&lt;/span&gt; because that makes the code below simpler
when I start downloading more than one page concurrently.&lt;/p&gt;
&lt;p&gt;Visually, I can draw the &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;text&lt;/span&gt; calls like this:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/get-and-text.png&quot;&gt;
&lt;p&gt;First I call &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and wait, then I call &lt;span
class=&quot;code&quot;&gt;text&lt;/span&gt; and wait.&lt;/p&gt;
&lt;p&gt;But what is asynchronous about this? This reads like normal, single threaded
code. I do one thing, then I do another.&lt;/p&gt;
&lt;h2&gt;Sending 3 Concurrent Requests&lt;/h2&gt;
&lt;p&gt;The magic happens when I have more than one request I want to make in parallel. Let’s use three hard coded path strings:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;vec![
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/1.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/2.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;https://example.com/3.html&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.to_string(),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;To download the 3 HTML files in parallel, I spawn three Tokio “tasks” and wait
for them all to complete. (This requires adding the futures crate to
Cargo.toml, which implements &lt;span class=&quot;code&quot;&gt;join_all&lt;/span&gt;.)&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Iterate over the paths.
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; tasks: Vec&amp;lt;JoinHandle&amp;lt;Result&amp;lt;(), ()&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;vec![];
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Copy each path into a new string
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// that can be consumed/captured by the task closure
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; path.clone();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Create a Tokio task for each path
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    tasks.push(tokio::spawn(async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;move &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(())
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }));
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a7adba;&quot;&gt;// Wait for them all to finish
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Started &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; tasks. Waiting...&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, tasks.len());
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;join_all(tasks).await;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Each Tokio task is a closure passed to the &lt;span
class=&quot;code&quot;&gt;tokio::spawn&lt;/span&gt; function, marked &lt;span class=&quot;code&quot;&gt;async
move&lt;/span&gt;. I create a copy of each path, using &lt;span
class=&quot;code&quot;&gt;path.clone()&lt;/span&gt;, so the closure has its own copy of the path
string with its own lifetime.&lt;/p&gt;
&lt;p&gt;The complex type annotation on the &lt;span class=&quot;code&quot;&gt;tasks&lt;/span&gt; array
indicates what each call to &lt;span class=&quot;code&quot;&gt;spawn&lt;/span&gt; returns: a &lt;span
class=&quot;code&quot;&gt;JoinHandle&lt;/span&gt; enclosing a &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt;. To
keep things simple, I handle all errors in the closure and just return &lt;span
class=&quot;code&quot;&gt;Ok(())&lt;/span&gt;.  This means each &lt;span
class=&quot;code&quot;&gt;JoinHandle&lt;/span&gt; contains a trivial result: &lt;span
class=&quot;code&quot;&gt;Result&amp;lt;(), ()&amp;gt;&lt;/span&gt;. I could have written the closure to return
some value and/or some error value instead.&lt;/p&gt;
&lt;p&gt;After the loop is finished and all three tasks have been spawned, I call &lt;span
class=&quot;code&quot;&gt;join_all(tasks).await&lt;/span&gt; to wait for them all to finish.&lt;/p&gt;
&lt;h2&gt;Asynchronous vs Multithreaded&lt;/h2&gt;
&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/traffic-light2.jpg&quot;&gt;&lt;br/&gt;
  &lt;small&gt;(from: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Traffic_lights,_Zl%C3%ADn.JPG&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;At first glance, it looks like this code is spawning three different threads. I
even call a spawn function. A multithreaded download might look like this:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/multithreaded.png&quot;&gt;
&lt;p&gt;We have 3 paths, so we have 3 threads. Each thread calls &lt;span class=&quot;code&quot;&gt;get&lt;/span&gt; and waits, and
then calls &lt;span class=&quot;code&quot;&gt;text&lt;/span&gt; and waits.&lt;/p&gt;
&lt;p&gt;However, Rust’s Tokio engine doesn’t work that way. Instead of launching an
entirely new thread for each task, it runs all three tasks on the same thread.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update&lt;/em&gt;: Wesley Moore &lt;a href=&quot;https://twitter.com/wezm/status/1219734031857635329&quot;&gt;pointed out on
Twitter&lt;/a&gt; that: &amp;quot;Tokio
multiplexes m tasks into a pool of n threads so it’s able to use all available
cores. (M:N threading).&amp;quot; It looks like Tokio supports both a Basic (single
threaded) and Threaded (thread pool) Scheduler; see &lt;a href=&quot;https://docs.rs/tokio/0.2.10/tokio/runtime/index.html#threaded-scheduler&quot;&gt;the
docs&lt;/a&gt;
for more information.&lt;/p&gt;
&lt;p&gt;I imagine three tasks running on one thread like this:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/one-thread.png&quot;&gt;
&lt;p&gt;Each time I call &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt;, Rust stops one task and
starts another using the same thread. In fact, depending on how long it takes
for each task to complete, they might be run in a different order:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/different-order.png&quot;&gt;
&lt;p&gt;There’s no way to predict ahead of time what order the tasks will run it.
That’s why I needed to copy each path string above; each task needs it own copy
of the string with its own independent lifetime because it might be run at any
time.&lt;/p&gt;
&lt;p&gt;The only guarantee I have is that the &lt;span class=&quot;code&quot;&gt;join_all&lt;/span&gt; call
at the bottom will block until all of the tasks have finished; that is, until
all of the futures I pushed onto the tasks array have completed.&lt;/p&gt;
&lt;h2&gt;Sending 100,000 Concurrent Requests&lt;/h2&gt;
&lt;p&gt;I can scale this up to 100,000 requests by reading the URLs in from a file instead:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;read_lines&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(path: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;str&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) -&amp;gt; Result&amp;lt;Vec&amp;lt;String&amp;gt;, Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(path)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; reader &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;BufReader::new(file);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        reader.lines().filter_map(Result::ok).collect()
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    )
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#[tokio::main]
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;	&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; paths: Vec&amp;lt;String&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;read_lines(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;urls.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;When I tried this out for the first time I was excited: How long would it take
to download 100,000 HTML pages simultaneously like this? Would it be 100,000x
faster than downloading one file? I typed &lt;span class=&quot;code&quot;&gt;cargo run
--release&lt;/span&gt; to build my code in release mode and get the best possible
performance out of Rust. Asynchronous code, zero cost abstractions, no garbage
collector, this was going to be great!&lt;/p&gt;
&lt;p&gt;Of course, it didn’t work.&lt;/p&gt;
&lt;p&gt;What happened? The problem is the web server can't handle so many concurrent network
connections. Using my thread/task diagram, launching all 100,000 tasks might
look like this:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/simultaneous.png&quot;&gt;
&lt;p&gt;I spawn 100,000 tasks all on to the same thread, and Tokio starts executing
them all. Each time my code above calls &lt;span
class=&quot;code&quot;&gt;get(&amp;amp;path).await&lt;/span&gt;, Tokio pauses that task and starts
another, which calls &lt;span class=&quot;code&quot;&gt;get(&amp;amp;path).await&lt;/span&gt; again, opening
yet another HTTP request. My laptop quickly runs out of network resources and
these tasks start to fail.&lt;/p&gt;
&lt;h2&gt;Sending a Buffered, Concurrent Stream of 100,000 Requests&lt;/h2&gt;
&lt;p&gt;Instead, I need to limit the number of concurrent Tokio tasks - the number of
concurrent HTTP requests. I need the diagram to look something like this:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2020/1/20/buffered.png&quot;&gt;
&lt;p&gt;After the first 8 tasks are started, the first 8 blue boxes on the left, Tokio
waits for at least one of them to complete before starting a 9th task. I
indicate this with the “max concurrency” arrow.&lt;/p&gt;
&lt;p&gt;Once one of the first 8 calls to &lt;span class=&quot;code&quot;&gt;reqwest::get&lt;/span&gt;
completes, Tokio is free to run a 9th task. The first &amp;quot;pop from buffer&amp;quot; arrow.
And once that 9th task or any other task completes, Tokio starts a 10th task,
etc., in this manner processing all 100,000 tasks 8 at a time.&lt;/p&gt;
&lt;p&gt;To achieve this, I can use &lt;span class=&quot;code&quot;&gt;StreamExt&lt;/span&gt; trait’s &lt;a
href=&quot;https://rust-lang-nursery.github.io/futures-api-docs/0.3.0-alpha.5/futures/stream/trait.StreamExt.html#method.buffer_unordered&quot;&gt;&lt;span
class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt;&lt;/a&gt; function:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; fetches &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;futures::stream::iter(
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    paths.into_iter().map(|path| {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        async &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;move &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;reqwest::get(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;path).await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Ok(resp) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; resp.text().await {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        Ok(text) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                            println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;RESPONSE: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; bytes from &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, text.len(), path);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                        Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR reading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Err(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ERROR downloading &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, path),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;})
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).buffer_unordered(&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).collect::&amp;lt;Vec&amp;lt;()&amp;gt;&amp;gt;();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Waiting...&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;fetches.await;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;First I create an iterator which maps all of the paths to my closures, and passes
them to &lt;span class=&quot;code&quot;&gt;futures::stream::iter&lt;/span&gt;.
This will create a list of futures, each one executing my closure.&lt;/p&gt;
&lt;p&gt;At the bottom I call &lt;span class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; and pass in 8.  The
code in &lt;span class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; will execute up to 8 futures
from the stream concurrently, and then start to buffer the remaining futures.
As each task completes, each HTTP request in my example, &lt;span
class=&quot;code&quot;&gt;buffer_unordered&lt;/span&gt; will pull another task out of its buffer
and execute it.&lt;/p&gt;
&lt;p&gt;This code will slowly but steadily iterate over the 100,000 URLs, downloading
them in parallel. Experimenting with this, it doesn’t seem to matter very much
exactly what level of concurrency I pick. I found the best performance when I
picked a concurrency of 50. Using 50 concurrent Tokio tasks, it took about 30
minutes to download all one hundred thousand HTML files.&lt;/p&gt;
&lt;p&gt;However, none of that matters. I’m not measuring the performance of Rust, Tokio
or Reqwest. These numbers have more to do with the web server and network
connection I’m using. The real performance here was my own developer
performance: With just a few lines of code I was able to write an asynchronous
I/O program that can scale as much as I would like. The &lt;span
class=&quot;code&quot;&gt;async&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;await&lt;/span&gt; keywords make
this code easy to write and easy to read.&lt;/p&gt;
</content></entry><entry><title>Using Result Combinator Functions in Rust</title><link href="http://patshaughnessy.net/2019/11/19/using-result-combinator-functions-in-rust" rel="alternate"></link><id href="http://patshaughnessy.net/2019/11/19/using-result-combinator-functions-in-rust" rel="alternate"></id><published>2019-11-19T00:00:00Z</published><updated>2019-11-19T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/11/19/train-yard.jpeg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust’s Result type can help you control your program’s&lt;br/&gt;
  flow by checking for errors in a succinct, elegant way&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Using Rust for the first time, error handling was my biggest stumbling block.
Was this v</summary><content type="html">&lt;div style=&quot;float: right; padding: 8px 0px 20px 30px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/11/19/train-yard.jpeg&quot;&gt;&lt;br/&gt;
  &lt;i&gt;Rust’s Result type can help you control your program’s&lt;br/&gt;
  flow by checking for errors in a succinct, elegant way&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Using Rust for the first time, error handling was my biggest stumbling block.
Was this value a &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; or just a T?  And the
right T? The right E? I couldn’t just write the code I wanted to write. It
felt confusing and overly elaborate.&lt;/p&gt;
&lt;p&gt;But after a while, I started to get a feel for the basics of using &lt;span
class=&quot;code&quot;&gt;Result&lt;/span&gt;. I discovered that the combinator methods Result
provides, like &lt;span class=&quot;code&quot;&gt;map&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;or_else&lt;/span&gt;
and &lt;span class=&quot;code&quot;&gt;ok&lt;/span&gt;, made error handling fun. Well, maybe
that's a bit of an overstatement. They made using &lt;span
class=&quot;code&quot;&gt;Result&lt;/span&gt; a bit easier, at least.&lt;/p&gt;
&lt;p&gt;So far my favorite &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; combinator method is
&lt;a
href=&quot;https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then&quot;&gt;&lt;span
class=&quot;code&quot;&gt;and_then&lt;/span&gt;&lt;/a&gt;. Using &lt;span class=&quot;code&quot;&gt;and_then&lt;/span&gt; &lt;em&gt;is&lt;/em&gt;
actually fun! For example, I wrote &lt;a href=&quot;https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/src/lib.rs#L43&quot;&gt;this Rust
code&lt;/a&gt;
to generate the static HTML pages for this blog site:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; count &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; all_posts.len();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;all_posts.sort_by_key(|p| Reverse(p.date));
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; params &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; CompileParams {all_posts: all_posts, output_path: output_path, draft: draft};
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Ok(params).and_then(compile_posts)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .and_then(compile_home_page)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .and_then(compile_rss_feed)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .map(|_output| count)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Ignoring the details about sorting and counting, my code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First creates a struct holding input parameters, and wraps it using &lt;span class=&quot;code&quot;&gt;Ok(params)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;And then&lt;/em&gt; tries to compile all the posts in my blog, passing in the input parameters&lt;/li&gt;
&lt;li&gt;&lt;em&gt;And then&lt;/em&gt; if this was successful, it tries to compile the home page
(index.html)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;And then&lt;/em&gt; if this was successful, it tries to compile the RSS feed (index.xml)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If there was an error at any time in this process, it short circuits and stops.
Here’s a flowchart that illustrates this control flow:&lt;/p&gt;
&lt;div style=&quot;margin-left: auto; margin-right: auto; width:235px&quot;&gt;
&lt;br/&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2019/11/19/flowchart.png&quot;&gt;
&lt;/div&gt;
&lt;p&gt;The happy path is from top to bottom, along the left side. If any of the
compile methods fail, &lt;span class=&quot;code&quot;&gt;and_then&lt;/span&gt; short circuits the
happy path and jumps to the end.&lt;/p&gt;
&lt;h2&gt;Matching Result Types&lt;/h2&gt;
&lt;p&gt;To chain &lt;span class=&quot;code&quot;&gt;and_then&lt;/span&gt; methods together like this, I used
the same input and output types for each of the compile methods:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_posts&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params: CompileParams) -&amp;gt; Result&amp;lt;CompileParams, InvalidPostError&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_home_page&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params: CompileParams) -&amp;gt; Result&amp;lt;CompileParams, InvalidPostError&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_rss_feed&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params: CompileParams) -&amp;gt; Result&amp;lt;CompileParams, InvalidPostError&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Each method expects a &lt;span class=&quot;code&quot;&gt;CompileParams&lt;/span&gt; struct, and
returns one wrapped in &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt;. Rust unwraps the &lt;span
class=&quot;code&quot;&gt;CompileParams&lt;/span&gt; from one call and passes it to the next.&lt;/p&gt;
&lt;p&gt;I use &lt;span class=&quot;code&quot;&gt;InvalidPostError&lt;/span&gt; throughout my code to provide
a consistent way to return errors. This was a bit of a challenge at first,
until I realized it was easy to cast other types of errors into
&lt;span class=&quot;code&quot;&gt;InvalidPostError&lt;/span&gt; like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;impl &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;From&amp;lt;std::io::Error&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;InvalidPostError {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;from&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(e: std::io::Error) -&amp;gt; InvalidPostError {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; message &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;format!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        InvalidPostError::new(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;message)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Now the Rust compiler knows how to map a &lt;span class=&quot;code&quot;&gt;std::io::Error&lt;/span&gt; into an &lt;span class=&quot;code&quot;&gt;InvalidPostError&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Error Handling the Old Fashioned Way&lt;/h2&gt;
&lt;p&gt;Here’s the code I didn’t have to write: (This is Ruby; substitute your favorite
PL that doesn't support &lt;a href=&quot;https://medium.com/@huund/monadic-error-handling-1e2ce66e3810&quot;&gt;monadic error
handling&lt;/a&gt;.)&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; compile_posts(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; compile_home_page(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; compile_rss_feed(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Success!&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Error compiling RSS Feed&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Error compiling home page&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Error compiling a blog post&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;I didn’t have to write a series of if/else blocks. This would have been tedious
to write and tedious to read. And I probably would have forgotten (or have been
too lazy) to check one of the return values.&lt;/p&gt;
&lt;p&gt;And I didn’t have to write this code either:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_posts&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;raise &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;InvalidPostError&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Failed compiling the posts&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_home_page&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;raise &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;InvalidPostError&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Failed compiling the home page&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;def &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;compile_rss_feed&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;raise &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;InvalidPostError&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.&lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Failed compiling the RSS feed&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;begin
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  compile_posts(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  compile_home_page(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  compile_rss_feed(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Success&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;rescue &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;InvalidPostError =&amp;gt; e
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts e.message
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Once again this is fragile: I might raise the wrong exception type or not raise
one at all. Or I might rescue the wrong type. Worse, there’s no indication at
the call site what might happen.&lt;/p&gt;
&lt;p&gt;To be honest, I probably won’t bother handling errors at all for a simple Ruby
script like this. If an exception happens someday while building my blog site,
then I’ll deal with it then. I’d probably just write this code:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;compile_posts(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;compile_home_page(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;compile_rss_feed(params)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Success&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Rust Error Handling: Easy To Read, Hard To Write&lt;/h2&gt;
&lt;p&gt;Combining results together using &lt;span class=&quot;code&quot;&gt;and_then&lt;/span&gt; and other
&lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; functions enables me to write error checking
code in a natural, succinct way:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Ok(params).and_then(compile_posts)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .and_then(compile_home_page)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          .and_then(compile_rss_feed)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This is just as simple to read as the Ruby version above that doesn’t check for
any errors. While it’s harder to write, having the Rust compiler check my
thought process as I piece together different code paths is a huge help.
Learning to use and get along with the Rust compiler is worth it: You end up
with code that is both readable and correct.&lt;/p&gt;
</content></entry><entry><title>How Rust Makes Error Handling Part of the Language</title><link href="http://patshaughnessy.net/2019/10/3/how-rust-makes-error-handling-part-of-the-language" rel="alternate"></link><id href="http://patshaughnessy.net/2019/10/3/how-rust-makes-error-handling-part-of-the-language" rel="alternate"></id><published>2019-10-03T00:00:00Z</published><updated>2019-10-03T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/fingers-toes.png&quot;&gt;&lt;br/&gt;
&lt;i&gt;In Spanish these are all “dedos,” while in English&lt;br/&gt;we can distinguish between fingers and toes. &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Learning a foreign language can be an incredible experience, not only because
you can talk to new people, v</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/fingers-toes.png&quot;&gt;&lt;br/&gt;
&lt;i&gt;In Spanish these are all “dedos,” while in English&lt;br/&gt;we can distinguish between fingers and toes. &lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Learning a foreign language can be an incredible experience, not only because
you can talk to new people, visit new countries, read new books, etc. When you
learn the words someone from a different culture uses, you start to see things
from their perspective. You understand the way they think a bit more.&lt;/p&gt;
&lt;p&gt;The same is true for programming languages. Learning the syntax, keywords and
patterns of a new programming language enables you to think about problems from
a different perspective. You learn to solve problems in a different way.&lt;/p&gt;
&lt;p&gt;I’ve been studying &lt;a href=&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt; recently, a new
programming language for me. As a Ruby developer, I was curious to learn how
Rust developers approach solving problems. What do Rust programs look like?
What new words would I learn?&lt;/p&gt;
&lt;h2&gt;Why Rust Was Difficult For Me&lt;/h2&gt;
&lt;p&gt;I knew it would be a challenge to learn Rust. I had heard horror stories about
how difficult the Rust compiler can be to use, or about how confusing the
ownership memory model and the borrow checker can be. And I was right: Rust is
a very difficult language to learn. But not because of move semantics or memory
management.&lt;/p&gt;
&lt;p&gt;For me, the most challenging syntax in Rust had to do with simple error
handling. Let’s take an example: opening and reading a text file. In Ruby, this
is a one-liner and error handling is completely optional:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;string &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;File&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.read(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;In Ruby, &lt;span class=&quot;code&quot;&gt;File.read&lt;/span&gt; returns a simple string. Will this
ever return an error? Who knows. Maybe Ruby will raise an exception, maybe not.
I don’t have to worry about that at the call site when I’m writing the code. I
can focus on the happy path, but I end up with a program that can’t handle
errors.&lt;/p&gt;
&lt;p&gt;Golang, at least, returns an error value explicitly when I try to read a file:&lt;/p&gt;
&lt;pre&gt;
b, err := ioutil.ReadFile(&quot;foo.txt&quot;)
if err != nil {
    fmt.Print(err)
} else {
    str := string(b)
}
&lt;/pre&gt;
&lt;p&gt;Here the Golang &lt;span class=&quot;code&quot;&gt;ioutil.ReadFile&lt;/span&gt; function returns two
values: the string I want and also an error value. The Go compiler forces me to
think about errors that might occur, at least for a moment. But error handling
is still optional. I can simply choose to ignore the &lt;span
class=&quot;code&quot;&gt;err&lt;/span&gt; value entirely. Most C programs work in a similar
fashion, returning an error code in some manner.  And if I do choose to handle
the error, I end up with verbose, messy code that checks for error codes over
and over again.&lt;/p&gt;
&lt;p&gt;In Rust error handling in mandatory. Let’s try to rewrite the same example
using Rust:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;file.read_to_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents);
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Right away I run into trouble when I try to compile this:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
error[E0599]: no method named `read_to_string` found for type
`std::result::Result&amp;lt;std::fs::File, std::io::Error&gt;` in the current scope
&lt;/pre&gt;
&lt;p&gt;What? What is the Rust compiler talking about? I can see there’s a &lt;span
class=&quot;code&quot;&gt;read_to_string&lt;/span&gt; method on the &lt;span class=&quot;code&quot;&gt;File&lt;/span&gt;
struct &lt;a href=&quot;https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string&quot;&gt;right in the
documentation&lt;/a&gt;!
(Actually the method is on the &lt;span class=&quot;code&quot;&gt;Read&lt;/span&gt; trait which &lt;span
class=&quot;code&quot;&gt;File&lt;/span&gt; implements.) The problem is the &lt;span
class=&quot;code&quot;&gt;File::open&lt;/span&gt; function doesn’t return a file at all. It
returns a value of type &lt;span class=&quot;code&quot;&gt;io::Result&amp;lt;File&amp;gt;&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;pub fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;open&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; io::Result&amp;lt;File&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;How do I use this? What does &lt;span class=&quot;code&quot;&gt;io::Result&amp;lt;File&amp;gt;&lt;/span&gt; even
mean? When I try to write Rust code the way I write Ruby or Go code, I get
cryptic errors and it doesn’t work.&lt;/p&gt;
&lt;p&gt;The problem is I’m trying to speak Rust the same way I speak in Ruby. Rust is a
foreign language; I need to learn some vocabulary before I can try to talk to
someone. This is why Rust is difficult to learn. It’s a foreign language that
uses many words completely unfamiliar to most developers.&lt;/p&gt;
&lt;h2&gt;Types Are the Vocabulary of Programming Languages&lt;/h2&gt;
&lt;p&gt;My wife is Spanish, and lucky for me she’s had the patience and the endurance
to teach me and our kids Spanish over the years. As a native English speaker,
it always seemed curious and amusing to me that Spanish has only one word for
fingers and toes, &lt;em&gt;dedos&lt;/em&gt;. Don’t people in Spain or Latin America ever need to
talk about only fingers and not toes? Or vice-versa? And in Spain I invariably
end up saying silly things like &lt;em&gt;dedos altos&lt;/em&gt; (“upper fingers”), or &lt;em&gt;dedos
bajos&lt;/em&gt; (“lower fingers”). I always worry about which digits I’m talking about.
Somehow, though, the Spanish never have any trouble with this; where the
&lt;em&gt;dedos&lt;/em&gt; are located always seems obvious to them from the context.&lt;/p&gt;
&lt;p&gt;But I wonder: Do Spanish speakers have trouble learning English when it comes
to fingers vs. toes? Do they ever say finger when they mean toe? The problem is
not just learning a new word. You have to learn the meaning behind the word.
English has a concept, a distinction, that Spanish doesn’t.&lt;/p&gt;
&lt;p&gt;Back to computer programming, the “words” we use in programming languages
aren’t only syntax tokens like if, else, let, etc. They are the values that we
pass around in our programs. And those values have types, even for loosely,
dynamically typed languages like Ruby.&lt;/p&gt;
&lt;p&gt;Aside from whatever formal definition Computer Science has for types, I simply
think of a value’s type as it’s meaning or purpose. To understand what role a
value plays in your program, you need to understand the concept behind its
type. Just like the words finger and toe represent certain anatomical concepts
in English, types like &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; or &lt;span
class=&quot;code&quot;&gt;Option&amp;lt;T&amp;gt;&lt;/span&gt; represent programming concepts in Rust - concepts
that foreigners need to learn for the first time.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
Language shapes the way we think, and determines what we can think about.&lt;br/&gt;
-- Benjamin Lee Whorf
&lt;/blockquote&gt;
&lt;p&gt;In fact, some linguists take this to the extreme: That a language’s words
determine what people in that community are able to think and talk about, what
concepts they can understand. (However, most modern linguists, &lt;a href=&quot;https://en.wikipedia.org/wiki/Linguistic_relativity&quot;&gt;according to
Wikipedia&lt;/a&gt;, don’t believe
this is actually true.)&lt;/p&gt;
&lt;p&gt;Because Rust includes the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; type, Rust
programmers are empowered to talk about error handling in a very natural way.
It’s part of their daily vocabulary. Of course, native Spanish speakers, I’m
guessing, have no trouble understanding the distinction between fingers and
toes. But I certainly have trouble understanding the concept behind &lt;span
class=&quot;code&quot;&gt;Result&lt;/span&gt; in Rust.&lt;/p&gt;
&lt;h2&gt;If Rust is Spanish, then Haskell is Latin&lt;/h2&gt;
&lt;p&gt;So what does &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; mean? What is a value of
type &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt;?&lt;/p&gt;
&lt;p&gt;Just as human language borrow words from other languages — many Spanish words
are taken from Latin or Arabic while English borrowed many words from French and
German — programming languages borrow words and concepts from other, older
programming languages.&lt;/p&gt;
&lt;p&gt;Rust borrowed the concept behind the &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt;
type from Haskell, a strongly typed functional programming language. Haskell
includes a type called &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;
data Either a b = Left a | Right b
&lt;/pre&gt;
&lt;p&gt;This syntax seems bizarre at first glance but in fact it’s simple. Haskell
makes it easy to create new types by combining other types together. This line
of code means the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; type is a combination of two
other types: &lt;span class=&quot;code&quot;&gt;a&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;b&lt;/span&gt;.
Drawing that type equation, this is how I visualize Haskell &lt;span
class=&quot;code&quot;&gt;Either&lt;/span&gt; values:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/left-or-right.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;A single &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; value can only encapsulate &lt;em&gt;either&lt;/em&gt;
a value of type &lt;span class=&quot;code&quot;&gt;a&lt;/span&gt; or a value of type &lt;span
class=&quot;code&quot;&gt;b&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; value is &lt;span
  class=&quot;code&quot;&gt;Left&lt;/span&gt;, then it contains an inner value of type &lt;span
  class=&quot;code&quot;&gt;a&lt;/span&gt;. This is written: &lt;span class=&quot;code&quot;&gt;Left a&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; value is &lt;span
  class=&quot;code&quot;&gt;Right&lt;/span&gt;, then it contains an inner value of type &lt;span
  class=&quot;code&quot;&gt;b&lt;/span&gt;. This is written: &lt;span class=&quot;code&quot;&gt;Right b&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; type is also “monad,” because Haskell 
provides certain functions that create and operate on &lt;span
class=&quot;code&quot;&gt;Either&lt;/span&gt; values. I won’t cover this concept here today, but
when I have time I'll discuss monads and how they can be applied to error
handling in a future post.&lt;/p&gt;
&lt;p&gt;In Haskell, the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; type is completely general,
and you can use it to represent any programming concept you would like.  Rust
uses the concept behind &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; for a specific
purpose: to implement error handling. If Haskell is Latin, then Rust is
Spanish, a younger language that borrows some of the older languages’s
vocabulary and grammar.&lt;/p&gt;
&lt;h2&gt;Result&amp;lt;T, E&amp;gt; in Rust&lt;/h2&gt;
&lt;p&gt;In Rust, the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; type encapsulates two other types
like &lt;span class=&quot;code&quot;&gt;Either.&lt;/span&gt; A single &lt;span
class=&quot;code&quot;&gt;Result&lt;/span&gt; value has either one of those types or the other:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/ok-or-err.png&quot;&gt;
&lt;p&gt;Instead of &lt;span class=&quot;code&quot;&gt;Left a&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;Right
b&lt;/span&gt; like in Haskell, Rust uses the words &lt;span class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt;
and &lt;span class=&quot;code&quot;&gt;Err(E)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; value is &lt;span
  class=&quot;code&quot;&gt;Ok&lt;/span&gt;, then it contains an inner value of type &lt;span
  class=&quot;code&quot;&gt;T&lt;/span&gt;. This is written: &lt;span class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt;.
&lt;span class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt; means some operation was successful, and the
result of the operation is a value of type &lt;span class=&quot;code&quot;&gt;T&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;span class=&quot;code&quot;&gt;Either&lt;/span&gt; value is &lt;span
  class=&quot;code&quot;&gt;Err,&lt;/span&gt; then it contains an inner value of type &lt;span
  class=&quot;code&quot;&gt;E&lt;/span&gt;. This is written: &lt;span class=&quot;code&quot;&gt;Err(E)&lt;/span&gt;
Similarly, this means the operation was a failure, and the result of the
operation is an error of type &lt;span class=&quot;code&quot;&gt;E&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Back to my open file example, the proper way to open a file and read it using
Rust is to check the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; values returned by the
Rust standard library functions:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(file) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;I have a file: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, file),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Err(e) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;There was an error: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;And If I want to actually read in the contents of that file, I would check that
return value also:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file.read_to_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Ok(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;_&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;The file&amp;#39;s contents are: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, contents),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;                Err(e) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;There was an error: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Err(e) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;There was an error: &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;The ? Operator In Rust&lt;/h2&gt;
&lt;p&gt;That last code snippet is quite a mouthful - error checking with Rust is even
more tedious and verbose than it is using Go!&lt;/p&gt;
&lt;p&gt;Fortunately, Rust includes an operator that allows Rust programmers to
abbreviate all of this logic. By appending the &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt;
character to the call site of a function that returns a &lt;span
class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; value, Rust automatically generates code
that checks the &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; value, and returns
underlying &lt;span class=&quot;code&quot;&gt;T&lt;/span&gt; value if the result is &lt;span
class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    file.read_to_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Here, the use of &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt; after &lt;span
class=&quot;code&quot;&gt;File::open(&amp;quot;foo.txt&amp;quot;)&lt;/span&gt; tells the Rust compiler to check the
return value of &lt;span class=&quot;code&quot;&gt;File::open&lt;/span&gt; for me automatically:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/success-or-failure.png&quot;&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;If the return value of &lt;span class=&quot;code&quot;&gt;File::open&lt;/span&gt; is &lt;span
class=&quot;code&quot;&gt;Ok(T)&lt;/span&gt;, then Rust assigns the inner &lt;span
class=&quot;code&quot;&gt;T&lt;/span&gt; value to &lt;span class=&quot;code&quot;&gt;file&lt;/span&gt;. If &lt;span
class=&quot;code&quot;&gt;File::open&lt;/span&gt; returns &lt;span class=&quot;code&quot;&gt;Err(E)&lt;/span&gt;, then
Rust jumps to the end of the &lt;span class=&quot;code&quot;&gt;main&lt;/span&gt; function
immediately and returns.&lt;/p&gt;
&lt;p&gt;The program above is much more concise and easy to understand. The only problem
is that it doesn’t work! When I try to compile this, I get:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option`
(or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:5:20
  |
5 |     let mut file = File::open(&quot;foo.txt&quot;)?;
  |                    ^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in
  a function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
&lt;/pre&gt;
&lt;h2&gt;Rust Programs Revolve Around Error Handling&lt;/h2&gt;
&lt;p&gt;As the error message says, the problem here is that the &lt;span
class=&quot;code&quot;&gt;?&lt;/span&gt; operator generates code that will jump to the end of the
main function and return the &lt;span class=&quot;code&quot;&gt;Err(E)&lt;/span&gt; value, where E is
of type &lt;span class=&quot;code&quot;&gt;std::io::Error&lt;/span&gt;. The problem is that I haven’t
declared a return value for &lt;span class=&quot;code&quot;&gt;main&lt;/span&gt;. Therefore the Rust
compiler gives me an error:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
the `?` operator can only be used in a function that returns `Result` or
`Option` (or another type that implements `std::ops::Try`)
&lt;/pre&gt;
&lt;p&gt;The function containing the use of the &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt; operator has
to return a value of type &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt; with a
matching &lt;span class=&quot;code&quot;&gt;E&lt;/span&gt; type in order for this to make sense. I
have to extract my &lt;span class=&quot;code&quot;&gt;File&lt;/span&gt; calls into a separate
function, like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;read&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() -&amp;gt; Result&amp;lt;String, std::io::Error&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; file &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;File::open(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;foo.txt&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    file.read_to_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; contents)&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;?&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    Ok(contents)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;match &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;read() {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Ok(&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;str&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;str&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;),
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        Err(e) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{:?}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, e)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Note the new &lt;span class=&quot;code&quot;&gt;read()&lt;/span&gt; function above returns a value of
type &lt;span class=&quot;code&quot;&gt;Result&amp;lt;String, std::io::Error&amp;gt;&lt;/span&gt;. This allows the
use of the &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt; operator to compile properly. For the
happy path, if my code is able to find the “foo.txt” file and read it, then
&lt;span class=&quot;code&quot;&gt;read()&lt;/span&gt; returns &lt;span
class=&quot;code&quot;&gt;Ok(contents)&lt;/span&gt;. However, if there’s an error, &lt;span
class=&quot;code&quot;&gt;read()&lt;/span&gt; will return &lt;span class=&quot;code&quot;&gt;Err(e)&lt;/span&gt;, where
&lt;span class=&quot;code&quot;&gt;e&lt;/span&gt; is a value of type &lt;span
class=&quot;code&quot;&gt;std::io::Error&lt;/span&gt;. Note &lt;span class=&quot;code&quot;&gt;open&lt;/span&gt; returns
the same error type that &lt;span class=&quot;code&quot;&gt;read&lt;/span&gt; does:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2019/10/3/error-types.png&quot;&gt;
&lt;p&gt;This is where Rust shines. It allows for concise and readable error handling
that is also thorough and correct. The Rust compiler checks for error handling
completeness at &lt;em&gt;compile time&lt;/em&gt;, before I ever run my program.&lt;/p&gt;
&lt;p&gt;Now that I’ve learned some vocabulary words, now that I can understand how
native Rust speakers use the word &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt;, I
can have a Rust conversation about error handling. I can begin to think like
Rust developers think. I can start to see things from their perspective.&lt;/p&gt;
&lt;p&gt;And I begin to realize that Rust programs tend to be designed with error
handling in mind. Notice above how I had to extract a separate function that
returned a value of type &lt;span class=&quot;code&quot;&gt;Result&amp;lt;T, E&amp;gt;&lt;/span&gt;, just
because of the &lt;span class=&quot;code&quot;&gt;?&lt;/span&gt; operator. The overall structure of
my program is determined by error handling just as much as it’s determined by
the nature of the task I’m trying to accomplish. Rust programmers think about
errors and what might go wrong from the very beginning, from when they start
writing code. To be honest, I've often thought about errors and what might go
wrong as an afterthought, after I've written and deployed my code.&lt;/p&gt;
</content></entry><entry><title>Using Rust to Build a Blog Site</title><link href="http://patshaughnessy.net/2019/9/4/using-rust-to-build-a-blog-site" rel="alternate"></link><id href="http://patshaughnessy.net/2019/9/4/using-rust-to-build-a-blog-site" rel="alternate"></id><published>2019-09-04T00:00:00Z</published><updated>2019-09-04T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/9/4/batteries.jpg&quot;&gt;&lt;br/&gt;
&lt;i&gt; Rust comes with batteries included&lt;br/&gt;
    &lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Neo-Geo-Pocket-Color-w-batteries.jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;After “Hello World,” blog sites a</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 20px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2019/9/4/batteries.jpg&quot;&gt;&lt;br/&gt;
&lt;i&gt; Rust comes with batteries included&lt;br/&gt;
    &lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Neo-Geo-Pocket-Color-w-batteries.jpg&quot;&gt;Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;After “Hello World,” blog sites are the world’s second most unneeded
application. If you want to write a blog, use Medium, Wordpress or just
Twitter. The world doesn’t need another blog app.&lt;/p&gt;
&lt;p&gt;However, like Hello World, building a static site generator is a great way to
get your feet wet in a new programming language. Recently I rewrote &lt;a href=&quot;https://github.com/patshaughnessy/patshaughnessy.github.io/blob/master/src/lib.rs&quot;&gt;the script
I use to generate this web
site&lt;/a&gt;
using Rust: I needed to update and fix my script, but really I was looking for
an excuse to write Rust.  Despite its reputation as a difficult to learn,
expert level language,  Rust turned out to be a great choice for the simple
task of generating a few HTML files, quickly and reliably. Why? Not because of
its sophisticated borrow checker or support for safe concurrency.&lt;/p&gt;
&lt;p&gt;Rust was a great choice for me because I didn’t have to write most of the code.
Rust’s dependency management and build tool,
&lt;a href=&quot;https://doc.rust-lang.org/book/ch01-03-hello-cargo.html&quot;&gt;Cargo&lt;/a&gt;, allowed me to
glue together open source Rust libraries called “crates” which do most of the
work. The Rust community’s crate registry, &lt;a href=&quot;https://crates.io&quot;&gt;crates.io&lt;/a&gt;, has
over 29,000 crates available.  Downloading, compiling and using them is dead
simple. And writing a blog site using Rust turned out to be simple too.&lt;/p&gt;
&lt;h2&gt;My Cargo.toml File&lt;/h2&gt;
&lt;p&gt;I needed a few important features to generate this web site. I wanted my script
to work like this for each blog post:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2019/9/4/flowchart.png&quot;/&gt;
&lt;p&gt;For each blog post, My new Rust script had to: parse the markdown source file
and convert it to HTML markup, highlight the syntax of my code snippets using
&amp;lt;style&amp;gt; tags and CSS, and use a template to insert the HTML for each post
into the surrounding web layout/design. Sounds like a lot of work, right?&lt;/p&gt;
&lt;p&gt;Wrong. Other Rust developers smarter than me had already implemented all of
this. All I had to do was find the crates I needed and add them to my
Cargo.toml file:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
[dependencies]
maud = &quot;*&quot;
pulldown-cmark = &quot;*&quot;
syntect = &quot;3.0&quot;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/raphlinus/pulldown-cmark&quot;&gt;Pulldown-cmark&lt;/a&gt; is a markdown
parser crate, &lt;a href=&quot;https://github.com/trishume/syntect&quot;&gt;Syntect&lt;/a&gt; is a color syntax
highlighting crate, and &lt;a href=&quot;https://github.com/lfairy/maud&quot;&gt;Maud&lt;/a&gt; is an HTML
template crate. Actually, to be honest I ended up adding a few other crates to
get my script to work:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
[dependencies]
maud = &quot;\*&quot;
pulldown-cmark = &quot;\*&quot;
regex = &quot;\*&quot;
lazy_static = &quot;\*&quot;
syntect = &quot;3.0&quot;
chrono = &quot;\*&quot;
clap = &quot;\*&quot;
ordinal = &quot;\*&quot;
&lt;/pre&gt;
&lt;p&gt;I’m not sure why, but the Rust standard library is very minimal. Features that
are included in other languages, like regular expressions or date/time parsing,
are handled by crates (e.g. regex and chrono).&lt;/p&gt;
&lt;p&gt;In any case, all I had to do was build my project and Cargo downloaded
everything I needed:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
$ cargo build --release
    Updating crates.io index
  Downloaded chrono v0.4.7
  Downloaded clap v2.33.0
  Downloaded maud v0.19.0
  Downloaded lazy_static v1.2.0
  Downloaded pulldown-cmark v0.2.0
  Downloaded ordinal v0.2.2
  Downloaded regex v1.1.0
  Downloaded syntect v3.0.2
  Downloaded libc v0.2.44
  Downloaded num-integer v0.1.41
  Downloaded num-traits v0.2.8
  Downloaded time v0.1.42

etc…
   Compiling syntect v3.0.2
   Compiling blogc v0.1.0 (/Users/pat/apps/patshaughnessy.github.io)
    Finished release [optimized] target(s) in 2m 27s
&lt;/pre&gt;
&lt;p&gt;It couldn’t be easier! During the rest of this post, I’ll show you how I used
these three crates: Pulldown-cmark, Syntect and Maud.&lt;/p&gt;
&lt;h2&gt;Pulldown-cmark&lt;/h2&gt;
&lt;p&gt;Now that my blog app included the Pulldown-mark crate, using it was just a
matter of pasting in a few of lines of code from the &lt;a href=&quot;https://docs.rs/pulldown-cmark/0.5.3/pulldown_cmark/html/fn.push_html.html&quot;&gt;helpful example on
docs.rs&lt;/a&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; parser &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Parser::new(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;markdown);
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; html &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;html::push_html(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; html, parser);
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The first line created a &lt;span class=&quot;code&quot;&gt;Parser&lt;/span&gt; struct, passing in a
reference to my markdown string. Then I created an empty, mutable target
string, called &lt;span class=&quot;code&quot;&gt;html&lt;/span&gt;. Last, I called the &lt;span
class=&quot;code&quot;&gt;push_html&lt;/span&gt; function which parsed the markdown source,
converted it to HTML and saved it into &lt;span class=&quot;code&quot;&gt;html&lt;/span&gt;. I didn’t
have to do any work whatsoever.&lt;/p&gt;
&lt;p&gt;In fact, the only real work for me had to do with “header” strings present at
the top of each post source file. For example, the
&lt;a href=&quot;https://raw.githubusercontent.com/patshaughnessy/patshaughnessy.github.io/master/posts/2017-12-15-looking-inside-postgres-at-a-gist-index.markdown&quot;&gt;2017-12-15-looking-inside-postgres-at-a-gist-index.markdown&lt;/a&gt;
file starts with:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
title: &quot;Looking Inside Postgres at a GiST Index&quot;
date: 2017/12/15
tag: the Postgres LTREE Extension

etc…
&lt;/pre&gt;
&lt;p&gt;Here the first three lines are metadata values about the post and not part of
the post content. So before calling Pulldown-mark, my script parses and
removes these header lines:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;other_lines&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(lines: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Vec&amp;lt;String&amp;gt;) -&amp;gt; Vec&amp;lt;String&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  lines.iter().skip_while(|l| is_header(l)).map(|l| l.to_string()).collect()
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Above the &lt;span class=&quot;code&quot;&gt;lines&lt;/span&gt; parameter is an array of strings,
each a single line of text in the markdown source file. (More precisely, it’s a
reference to a &lt;span class=&quot;code&quot;&gt;Vec&amp;lt;String&amp;gt;&lt;/span&gt;, not an array.) The code
is fairly readable: &lt;span class=&quot;code&quot;&gt;other_lines&lt;/span&gt; creates an iterator
over the lines, skips the first few header lines, and then collects the
remaining lines into a second array which the function returns.&lt;/p&gt;
&lt;p&gt;Here’s the complete &lt;span class=&quot;code&quot;&gt;html_from_markdown&lt;/span&gt; function,
which calls &lt;span class=&quot;code&quot;&gt;other_lines&lt;/span&gt;, joins them together into a
single large string, and then passes that to Pulldown-mark:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;html_from_markdown&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(lines: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Vec&amp;lt;String&amp;gt;) -&amp;gt; Result&amp;lt;String, InvalidPostError&amp;gt; {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; markdown &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; line &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;other_lines(lines) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    markdown.push_str(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;line);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    markdown.push(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;\n&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; parser &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Parser::new(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;markdown);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; html &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String::new();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  html::push_html(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; html, parser);
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  Ok(with_delim_removed(with_highlighted_code_snippets(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;html)))
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Syntect&lt;/h2&gt;
&lt;p&gt;If you read the code above carefully, you’ll notice &lt;span
class=&quot;code&quot;&gt;html_from_markdown&lt;/span&gt; calls &lt;span
class=&quot;code&quot;&gt;with_highlighted_code_snippets&lt;/span&gt; before returning the HTML
for each post. This function performs color syntax highlighting.&lt;/p&gt;
&lt;p&gt;The code snippets in each of my blog posts appear inside of &amp;lt;pre&amp;gt;…&amp;lt;/pre&amp;gt;
tags.  And I use a “type” attribute to indicate the programming language of the
snippet. For example:&lt;/p&gt;
&lt;pre type=&quot;console&quot;&gt;
&amp;lt;pre type=&quot;ruby&quot;&gt;
puts &quot;This is Ruby code I’m writing about…&quot;
&amp;lt;/pre&gt;
&lt;/pre&gt;
&lt;p&gt;Like parsing markdown, syntax highlighting is a very complex task: The Syntect
crate has to parse the given code snippet, determine the semantic meaning of
each keyword in the snippet based on the provided programming language, and
then insert the proper color information. Thank goodness I didn’t have to write
that code!&lt;/p&gt;
&lt;p&gt;But using Syntect was easy:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;pub fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;highlighted_html_for_language&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(snippet: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;String, attributes: String) -&amp;gt; String {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  lazy_static! {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;static ref &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: SyntaxSet &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;SyntaxSet::load_from_folder(syntax_path()).unwrap();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;static ref &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: Theme &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;ThemeSet::get_theme(theme_path().as_path()).unwrap();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;static ref &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUBY_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;&amp;#39;static&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; SyntaxReference &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.find_syntax_by_extension(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;rb&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).unwrap();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;static ref &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUST_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;: &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;&amp;#39;static&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; SyntaxReference &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.find_syntax_by_extension(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;rs&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;).unwrap();
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; attributes.contains(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ruby&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    highlighted_html_for_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;snippet, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUBY_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  } &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; attributes.contains(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;rust&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    highlighted_html_for_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;snippet, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUST_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;First I used a &lt;span class=&quot;code&quot;&gt;lazy_static&lt;/span&gt; block to initialize a few
constant values.
(&lt;a href=&quot;https://github.com/rust-lang-nursery/lazy-static.rs&quot;&gt;lazy_static&lt;/a&gt; is another
crate I didn’t have to write!) Rust executes this block once the first time
it’s encountered and then never again. The values are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;SYNTAX_SET&lt;/span&gt;: These are the Sublime syntax files
describing each programming language I need to colorize. vim is my editor,
but I use Sublime for color syntax highlighting :) I just downloaded these
files for the languages I needed and checked them into my app.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;THEME&lt;/span&gt;: These are the Sublime “theme” files, which
select the colors to use for each type of code keyword. I found and adapted
one of these files. They play the role of a CSS file, but use XML syntax.
Weird, but not hard to figure out.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;RUBY_SYNTAX&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;RUST_SYNTAX&lt;/span&gt;,
etc. The lazy block also looks up the syntax language file for each language.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Later my &lt;span class=&quot;code&quot;&gt;highlighted_html_for_language&lt;/span&gt; function
checks which programming language my post displays, and calls &lt;span
class=&quot;code&quot;&gt;syntect::html::highlighted_html_for_string&lt;/span&gt; with the proper
values:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; attributes.contains(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;ruby&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    highlighted_html_for_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;snippet, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUBY_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  } &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;else if&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; attributes.contains(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;rust&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;) {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    highlighted_html_for_string(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;snippet, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;SYNTAX_SET&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RUST_SYNTAX&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;THEME&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;etc&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;...
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&quot;code&quot;&gt;attributes&lt;/span&gt; is the array of HTML attributes from the
&amp;lt;pre&amp;gt; tag surrounding the code snippet in my post source. My app uses
regular expressions to find the &amp;lt;pre&amp;gt;…&amp;lt;/pre&amp;gt; HTML blocks, parses the
attributes and provides them to &lt;span
class=&quot;code&quot;&gt;highlighted_html_for_language&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Maud&lt;/h2&gt;
&lt;p&gt;Now my script has HTML for each blog post. All I have to do now is save it in a
series of HTML files. But first I needed a template engine for Rust, like ERB
for Ruby or Mustache for node.js.&lt;/p&gt;
&lt;p&gt;This turned out to be one of the most fun parts of this project. I rewrote &lt;a href=&quot;https://github.com/patshaughnessy/patshaughnessy.github.io/tree/master/src/layout&quot;&gt;my
HTML
markup&lt;/a&gt;
using Maud &lt;span class=&quot;code&quot;&gt;@&lt;/span&gt; directives, like this:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;if let &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;Some(&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;ref&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; t) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; post.tag {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  div class&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;header&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;More on &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(t)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  div class&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;links&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    ul {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;@&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(link_url, link_title) &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; recent_links {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        li {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          a href&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;{ &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;/&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot; &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;(link_url) } {
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;            (link_title)
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;          }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;      }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  }
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;}
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Maud doesn’t parse the layout code at runtime, like ERB does in Ruby. Instead,
the &lt;span class=&quot;code&quot;&gt;@if&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;@for&lt;/span&gt; directives
above are macros. In fact, all of the HTML elements that appear above, like
&lt;span class=&quot;code&quot;&gt;div&lt;/span&gt; and &lt;span class=&quot;code&quot;&gt;ul&lt;/span&gt;, are macros
also. This means my Maud layout code is actually Rust code!  And that means the
Rust compiler will check it and make sure it’s valid before it ever runs.&lt;/p&gt;
&lt;p&gt;Converting my old ERB templates into Rust macros was a bit tedious, but it was
a great way to review and clean up my HTML. In fact, I found a number of
mistakes and errors in my HTML code that had been there for 10 years or longer.
It was like showing my dirty laundry to the Rust compiler. By the time the
compiler was done and let me compile my layout, it was very clean!&lt;/p&gt;
&lt;h2&gt;What It Worth It?&lt;/h2&gt;
&lt;p&gt;It took me several months on a spare time basis - an hour here an hour there -
to rewrite my blog in Rust. An experienced Rust developer working full time
could have done it in a day or two probably.&lt;/p&gt;
&lt;p&gt;What did I get for all this effort? Now I have a script that compiles all 146
of my markdown posts very quickly. My old Ruby script took 7.7 seconds to do
this, while the new Rust script only takes 0.28 seconds! That’s over 27 times
faster! In fact, the Rust code is so fast at parsing and compiling the markdown
files that I don’t check which files need to be recompiled by comparing
timestamps, i.e. what a Makefile would do during a build process. And I don’t
process the posts in parallel. Why bother? By the time I pressed ENTER and
looked up Rust was almost done building all 146 files in sequence, one after
the other.&lt;/p&gt;
&lt;p&gt;But what else did I get? The biggest improvement to my blog script, actually,
wasn’t the performance. It was the error handling I added. I didn’t mention
this above, but using the Rust standard library required me to use the
&lt;span class=&quot;code&quot;&gt;Result&amp;lt;T&amp;gt;&lt;/span&gt; generic type. This, in turn, forced me to
think about what might go wrong and what to do when it did go wrong. I’ll cover
this in my next article.  I ended up with a script that was much more reliable
and resilient to silly mistakes in my source files, and that gave me helpful
error messages… all the while running 27 times faster.&lt;/p&gt;
&lt;p&gt;However, the biggest benefit to rewriting my blog in Rust was that I clawed my
way up the Rust learning curve a bit. But that wouldn’t have been possible
without crates.io and Cargo. Using code from smarter, more seasoned Rust
developers gave me a chance to build a useful app, even as a beginner. Cargo
found, downloaded and compiled open source code from experts with just a few
simple commands.&lt;/p&gt;
</content></entry><entry><title>Summer School With The Rust Compiler</title><link href="http://patshaughnessy.net/2018/10/24/summer-school-with-the-rust-compiler" rel="alternate"></link><id href="http://patshaughnessy.net/2018/10/24/summer-school-with-the-rust-compiler" rel="alternate"></id><published>2018-10-24T00:00:00Z</published><updated>2018-10-24T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/10/24/steves-tweet.png&quot;&gt;&lt;br/&gt;
&lt;i&gt; &lt;small&gt;(source: &lt;a href=&quot;https://twitter.com/steveklabnik/status/1022518806814617601&quot;&gt;Steve Klabnik via Twitter&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;A few months ago, I saw this tweet from Steve. I'm not even sure what
&amp;quot;derridean</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/10/24/steves-tweet.png&quot;&gt;&lt;br/&gt;
&lt;i&gt; &lt;small&gt;(source: &lt;a href=&quot;https://twitter.com/steveklabnik/status/1022518806814617601&quot;&gt;Steve Klabnik via Twitter&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;A few months ago, I saw this tweet from Steve. I'm not even sure what
&amp;quot;derridean&amp;quot; means, but now the image of an insane coach pops into my head every
time I try to write Rust code.&lt;/p&gt;
&lt;p&gt;Learning Rust is hard for everyone, but it’s even worse for me because I’ve
been working with Ruby during past ten years. Switching to Rust from Ruby is
leaving an anything-goes hippie commune to a summer school for delinquent
programmers run by a sadistic and unforgiving teacher.&lt;/p&gt;
&lt;p&gt;Why would anyone use a compiler like this? The answer is simple: to learn how
to write better code. This past summer I had some free time and decided to
convert a simple Ruby script into Rust. As you’ll see, the Rust compiler beat
me up a few times; it wasn’t easy. But after some tough love I ended up
learning something, not only about Rust but about Ruby too.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;h2&gt;Iterating Over an Array in Ruby&lt;/h2&gt;
&lt;p&gt;Here’s my example program. It’s so short and simple you can read and understand
it in just a few seconds:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts i
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;When I ran it, the output was:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ ruby int-loop.rb
1
2
3
&lt;/pre&gt;
&lt;div style=&quot;float: right; padding: 70px 0px 30px 30px; text-align: center;&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/10/24/garden-earthly-delights.png&quot;&gt;&lt;br/&gt;
  &lt;i&gt;&lt;small&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/The_Garden_of_Earthly_Delights&quot;&gt;The Garden of Earthly Delights&lt;/a&gt; (detail), by Hieronymus Bosch&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;Ruby’s syntax and feature set are designed to make my life easier as a
developer.  Writing Ruby for me is as natural as writing English; it’s like
having a pleasant conversation with my computer. I’m living in the Garden of
Earthly Delights. If I can imagine a code change, I can write it. Using Ruby,
all of my dreams can come true.&lt;/p&gt;
&lt;p&gt;Next I decided to increment the values before printing them out. I added just
one line of code to my example, &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt;:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;]
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  puts i
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;As I expected, Ruby printed out 2 through 4:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ ruby int-loop.rb
2
3
4
&lt;/pre&gt;
&lt;p&gt;Of course, there are other ways to produce the same result. I could have used
&lt;span class=&quot;code&quot;&gt;puts i+1&lt;/span&gt;, or mapped the original array to a new array
&lt;span class=&quot;code&quot;&gt;[2, 3, 4]&lt;/span&gt;. But Ruby doesn’t care. Today I felt like
writing &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt;, and Ruby let me do it without
comment. Ruby is the parent of an unruly teenager that gets away with anything.&lt;/p&gt;
&lt;p&gt;As I found out later, using &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt; might have broken
a Computer Science rule or two, but I was blissfully unaware. What you don’t
know can’t hurt you. Ruby didn’t tell me anything might be wrong… but as we’ll
see Rust certainly did!&lt;/p&gt;
&lt;h2&gt;Rust: Similar to Ruby At First Glance&lt;/h2&gt;
&lt;p&gt;I was curious: What would the Rust compiler think of this example? I was able
to rewrite it in only a few minutes:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;I had to type semicolons after each line and use a &lt;span
class=&quot;code&quot;&gt;main&lt;/span&gt; function. A bit more typing, but really this is
exactly the same program. Running this, of course, produced the same result:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
1
2
3
&lt;/pre&gt;
&lt;p&gt;Then I decided to try using the same &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt; line from above:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;=&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Lesson One: Passing By Reference vs. Passing By Value&lt;/h2&gt;
&lt;p&gt;Compiling this, the Rust compiler hit me over the head with Computer Science!&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
error[E0271]: type mismatch resolving `&lt;&amp;i32 as std::ops::Add&lt;i32&gt;&gt;::Output == &amp;i32`
  --&gt; int-loop.rs:4:14
   |
 4 |         i = i+1;
   |              ^ expected i32, found &amp;i32
   |
   = note: expected type `i32`
              found type `&amp;i32`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0271`.
&lt;/pre&gt;
&lt;p&gt;What in the world does this mean? I wrote a very simple line of code, and got a
message straight out of type theory! The error &lt;span class=&quot;code&quot;&gt;type mismatch
resolving `&amp;lt;&amp;amp;i32 as std::ops::Add&amp;gt;::Output == &amp;amp;i32`&lt;/span&gt; makes no sense to me at
all.&lt;/p&gt;
&lt;p&gt;I decided to take the compiler’s suggestion and run the explain command:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc --explain E0271
This is because of a type mismatch between the associated type of some
trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)
and another type `U` that is required to be equal to `T::Bar`, but is not.
Examples follow.
&lt;/pre&gt;
&lt;p&gt;The explain output continued for about two more pages, with examples that
didn’t resemble my code at all. What is a trait? What is an associated type? I
didn’t use any of these more advanced Rust concepts in my simple script. Maybe
I needed a PhD. in Computer Science even to try to use Rust?&lt;/p&gt;
&lt;p&gt;Eventually, I figured it out. The key lines from the error message were:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
 4 |         i = i+1;
   |              ^ expected i32, found &amp;i32
&lt;/pre&gt;
&lt;p&gt;Rust is telling me that &lt;span class=&quot;code&quot;&gt;iter()&lt;/span&gt; yielded references to
integers, but my code expected an actual integer, not a reference to an
integer. But what are references, exactly?&lt;/p&gt;
&lt;p&gt;Running my code above, Ruby passed each integer from the array to my code as a
simple value:&lt;/p&gt;
&lt;img width=&quot;185&quot; src=&quot;http://patshaughnessy.net/assets/2018/10/24/ruby-passes-by-value.png&quot;/&gt;
&lt;p&gt;But Rust passed each integer from the array as a reference, or in other words
as a pointer to the value itself:&lt;/p&gt;
&lt;img width=&quot;287&quot; src=&quot;http://patshaughnessy.net/assets/2018/10/24/rust-passes-by-reference.png&quot;/&gt;
&lt;p&gt;In Ruby, of course, I didn’t have to worry about references, pointers or even
types, so none of this came up. Or at least that’s what I thought at the time.&lt;/p&gt;
&lt;h2&gt;Lesson Two: Borrowed Values&lt;/h2&gt;
&lt;p&gt;Ah - according to the Rust compiler’s error message I just had to dereference
the reference before using it. I changed &lt;span class=&quot;code&quot;&gt;i = i+1&lt;/span&gt; to
&lt;span class=&quot;code&quot;&gt;*i = *i+1&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= *&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Then Rust slapped me in the face again with more Computer Science:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
error[E0594]: cannot assign to immutable borrowed content `*i`
  --&gt; int-loop.rs:26:9
   |
26 |         *i = *i+1;
   |         ^^^^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0594`.
&lt;/pre&gt;
&lt;p&gt;Ugh. I guess that was a bad idea. What in the world happened here? I thought I
had the dereferencing syntax correct, &lt;span class=&quot;code&quot;&gt;*i&lt;/span&gt;, the same
syntax I’m used to from C.  Actually Rust didn’t complain about types any more
or about using a reference vs. a value. But what does “borrow as mutable” mean?
And why doesn’t Rust let me do that?&lt;/p&gt;
&lt;p&gt;Again, the problem here is that I don’t know enough Rust even to understand the
compiler’s error messages. I need to take a few months off from my day job and
read a book, or take a class. I need to understand Rust’s ownership model.&lt;/p&gt;
&lt;p&gt;In Rust, every value is “owned” by the spot in my code where I allocate that
value. In this example, the integers and the array that contains them are owned
by the &lt;span class=&quot;code&quot;&gt;main&lt;/span&gt; function. When the &lt;span
class=&quot;code&quot;&gt;main&lt;/span&gt; function goes out of scope, Rust frees the memory for
that array automatically. In this diagram, the red arrow shows where Rust
allocates the array (at the top), and where Rust frees it (at the bottom):&lt;/p&gt;
&lt;img width=&quot;339&quot; src=&quot;http://patshaughnessy.net/assets/2018/10/24/rust-lifetime.png&quot;/&gt;
&lt;p&gt;You can think of the red arrow as the “lifetime” of the array. When I pass a
value from one spot to another, when I call a function or a closure, I can
either “move” that value to the new function, or the function can ”borrow” it.
In this example, the call to &lt;span class=&quot;code&quot;&gt;iter()&lt;/span&gt; borrowed the
elements inside the array, passing a reference to each element into the
closure. The blue array in this diagram indicates each element of the array,
&lt;span class=&quot;code&quot;&gt;i&lt;/span&gt;, is a borrowed value inside the closure:&lt;/p&gt;
&lt;img width=&quot;334&quot; src=&quot;http://patshaughnessy.net/assets/2018/10/24/rust-borrow.png&quot;/&gt;
&lt;h2&gt;Lesson Three: Immutable vs. Mutable Values&lt;/h2&gt;
&lt;p&gt;But using borrowed values isn’t the problem here. The problem is that my code
tries to change them, or mutate them:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#4f5b66;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= *&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Because the value of &lt;span class=&quot;code&quot;&gt;i&lt;/span&gt; each time around the loop was
an element of the array, and because &lt;span class=&quot;code&quot;&gt;iter()&lt;/span&gt; borrowed
each element from the original array, the elements are marked as immutable,
just as the array was. Or at least I that’s how I understood the previous error
message.&lt;/p&gt;
&lt;p&gt;Back in the &lt;span class=&quot;code&quot;&gt;main&lt;/span&gt; function when I typed:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;…Rust created an immutable array of three integers. All variables in Rust are
immutable by default. Because it was immutable, my code can’t change it.&lt;/p&gt;
&lt;p&gt;Ah… so the fix is to mark my array as mutable:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= *&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;Lesson Four: Declaring Side Effects&lt;/h2&gt;
&lt;p&gt;Running the Rust compiler again, I got the same error along with a new warning:&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
error[E0594]: cannot assign to immutable borrowed content `*i`
  --&gt; int-loop.rs:14:9
   |
14 |         *i = *i+1;
   |         ^^^^^^^^^ cannot borrow as mutable

warning: variable does not need to be mutable
  --&gt; int-loop.rs:12:9
   |
12 |     let mut array = [1, 2, 3];
   |         ----^^^^^
   |         |
   |         help: remove this `mut`
   |
&lt;/pre&gt;
&lt;p&gt;Wait - so now Rust was telling me I shouldn’t add the &lt;span
class=&quot;code&quot;&gt;mut&lt;/span&gt; keyword? That my last change was dead wrong? Why was it
wrong? Probably I didn’t understand what “cannot borrow as mutable” really
meant.&lt;/p&gt;
&lt;p&gt;It took me a while to figure this out but eventually I ran into this &lt;a href=&quot;https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html&quot;&gt;great
article&lt;/a&gt;
which explained what I was doing wrong and how to fix it. I needed to use
&lt;span class=&quot;code&quot;&gt;iter_mut&lt;/span&gt; instead of &lt;span class=&quot;code&quot;&gt;iter&lt;/span&gt;. &lt;span
class=&quot;code&quot;&gt;iter_mut&lt;/span&gt; yields mutable references to the closure, while
&lt;span class=&quot;code&quot;&gt;iter&lt;/span&gt; yields normal, immutable references.&lt;/p&gt;
&lt;p&gt;That is, by calling &lt;span class=&quot;code&quot;&gt;iter_mut&lt;/span&gt; I’m declaring that the
code inside of the closure might mutate the elements of the array. This is
knowns as a &lt;em&gt;side effect&lt;/em&gt;. As a side effect of the iteration, the code inside
might also change the values of the collection it is iterating over. Rust
forced me to declare that my code might change the array.&lt;/p&gt;
&lt;p&gt;Finally, running my program with &lt;span class=&quot;code&quot;&gt;iter_mut&lt;/span&gt; finally worked!&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let mut&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter_mut() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;*&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= *&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;;&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;console&quot;&gt;
$ rustc int-loop.rs &amp;&amp; ./int-loop
2
3
4
&lt;/pre&gt;
&lt;h2&gt;What Rust Taught Me&lt;/h2&gt;
&lt;p&gt;My example today started out as a trivial, 4 line Ruby script. It was so
simple, there really wasn’t anything that could possibly go wrong when I ran
it. Then I added one simple line of code: i = i+1. When I added this to my Ruby
script, it worked just fine.&lt;/p&gt;
&lt;p&gt;As we saw, this line of code got the Rust compiler very angry. It slapped me in
the face with four Computer Science lessons. I learned:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;about passing values vs. passing references.&lt;/li&gt;
&lt;li&gt;about mutable vs. immutable values.&lt;/li&gt;
&lt;li&gt;about value ownership, lifetimes and borrowing values.&lt;/li&gt;
&lt;li&gt;about side effects, and declaring them.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can see, the Rust compiler is an amazing tool you can use to learn more
about Computer Science. The problem is that it’s hard to get along with.
Compiling a Rust program will fail over and over again until you your code is
100% correct. You need to have tremendous patience to use Rust, especially as a
beginner.&lt;/p&gt;
&lt;p&gt;Worse than that, the Rust compiler’s error messages are hard to understand, and
easy to misinterpret. They can seem to be self-contradictory as we saw above. The
Rust compiler assumes you already know what it is trying to teach you. Not only
is Rust a violent teacher, it’s a bad one. If I knew that &lt;span
class=&quot;code&quot;&gt;iter()&lt;/span&gt; borrowed immutable values, if I knew what
“borrowing” and “immutable” even meant, then I likely wouldn’t have run into
that compiler error in the first place.&lt;/p&gt;
&lt;p&gt;And Rust’s confusing error message lead me in the wrong direction. In this
example, I didn’t really want to mutate the array, I just wanted to print out
the incremented values. I could have just incremented an intermediate value and
left the original array alone. Instead, the complex error messages confused and
mislead me, and I never discovered this simpler code:&lt;/p&gt;
&lt;pre&gt;
&lt;span style=&quot;color:#a71d5d;&quot;&gt;fn &lt;/span&gt;&lt;span style=&quot;color:#795da3;&quot;&gt;main&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;let&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;[&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;];&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;for&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; i &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;in&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt; array.iter() {&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;        println!(&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;{}&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;, i&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;+&lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;);&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;    }&lt;/span&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The Rust compiler is an amazing tool for learning; the problem is you need to
have a deep understanding of the Rust language before you can use it
effectively. Rust needs a --beginner option. Using this option on the
command line would intstruct the compiler to produce error messages designed
for Rust learners, rather than Rust experts.&lt;/p&gt;
&lt;h2&gt;What Ruby Didn’t Tell Me&lt;/h2&gt;
&lt;p&gt;I had the opposite experience using Ruby. No confusing compiler errors; in
fact, no compiler at all. No types, no need to worry about immutability or
whether I’m passing references or values. Everything just worked.&lt;/p&gt;
&lt;p&gt;Or did it? Because Ruby passed integers by value, the array in my original
example wasn’t modified:&lt;/p&gt;
&lt;pre&gt;
array = [1, 2, 3]
for i in array
  i = i+1
  puts i
end
puts &quot;----&quot;
p array
&lt;/pre&gt;
&lt;pre class=&quot;console&quot;&gt;
$ ruby int-loop.rb
2
3
4
----
[1, 2, 3]
&lt;/pre&gt;
&lt;p&gt;This is probably a good thing. Side effects like mutating a collection while
iterating over it can easily lead to bugs. Maybe code later in my program
needed the original, unchanged values in that array? Maybe another thread was
trying to use that collection at the same time?&lt;/p&gt;
&lt;p&gt;The problem with using Ruby is that you don’t know what Ruby isn’t telling you.
Because Ruby didn’t display any warnings or error messages when I added &lt;span
class=&quot;code&quot;&gt;i = i+1&lt;/span&gt; to my loop, I didn’t even think about any of these
issues. Fortunately, Ruby didn't modify the array so it wasn't a problem.&lt;/p&gt;
&lt;p&gt;But suppose my array contained strings and not integers:&lt;/p&gt;
&lt;pre&gt;
array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
for str in array
    str = str &lt;&lt; &quot;-mutated&quot;
    puts str
end
puts &quot;----&quot;
p array
&lt;/pre&gt;
&lt;pre class=&quot;console&quot;&gt;
$ ruby string-loop.rb
one-mutated
two-mutated
three-mutated
----
[&quot;one-mutated&quot;, &quot;two-mutated&quot;, &quot;three-mutated&quot;]
&lt;/pre&gt;
&lt;p&gt;Now the array was mutated! It turns out Ruby passed integers to the closure by
value, but strings by reference. Updating each string inside the loop also
updated that string inside the array. Now my program will have bugs, unless the
point of running that loop was to mutate the array, and not just to print it
out.&lt;/p&gt;
</content></entry><entry><title>From ActiveRecord to Diesel</title><link href="http://patshaughnessy.net/2018/6/9/from-activerecord-to-diesel" rel="alternate"></link><id href="http://patshaughnessy.net/2018/6/9/from-activerecord-to-diesel" rel="alternate"></id><published>2018-06-09T00:00:00Z</published><updated>2018-06-09T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/exercise.jpg&quot;&gt;&lt;br/&gt;
&lt;i&gt; Learning something new every day
is exercise for your mind.&lt;/i&gt;&lt;br/&gt;
	&lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Defender_builds_routine_to_achieve_goals_140716-F-FW757-073.jpg&quot;&gt;Jeremy Bowcock via Wikimedia C</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/exercise.jpg&quot;&gt;&lt;br/&gt;
&lt;i&gt; Learning something new every day
is exercise for your mind.&lt;/i&gt;&lt;br/&gt;
	&lt;small&gt;(source: &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Defender_builds_routine_to_achieve_goals_140716-F-FW757-073.jpg&quot;&gt;Jeremy Bowcock via Wikimedia Commons&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt;
&lt;/div&gt;
&lt;p&gt;As software developers we’re paid to be professional learners. People hire us
(or should hire us) for what we are capable of learning, not for what we
already know. To stay in shape and keep up with our peers we need to practice
by learning something new every day. We need to get daily exercise for our
minds.&lt;/p&gt;
&lt;p&gt;For me the best way to do this is to make simple tasks harder. Many times each
day I need to copy files, parse XML, generate JSON, or send an HTTP request.
The boring daily chores of a modern knowledge worker. To make my life more
interesting and to exercise my mind, I sometimes choose new tools or
programming languages that are harder to use, not easier, to accomplish these
small tasks.&lt;/p&gt;
&lt;p&gt;Let’s take an example. Recently I needed to run a simple SQL query on a
Postgres database and produce a one-off report. I could have done this in 5
minutes using Ruby and ActiveRecord. Instead, I decided to use
&lt;a href=&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt; and &lt;a href=&quot;http://diesel.rs&quot;&gt;Diesel&lt;/a&gt; - a language
and a tool I hadn’t used before. Instead of 5 minutes it took several hours,
but I learned something new. I've written up the steps I took here today. Get
your mind’s exercise for today and read on to learn how to execute a SQL
statement using Rust.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;TL/DR&lt;/b&gt;: I posted &lt;a href=&quot;https://gist.github.com/patshaughnessy/db735e90d58376fdd550b35838aa5339&quot;&gt;the
code&lt;/a&gt;
from this article if you want to skip the explanation and just try it.&lt;/p&gt;
&lt;h2&gt;Running a SQL Query Using Ruby and ActiveRecord&lt;/h2&gt;
&lt;p&gt;My actual data set looked different, but suppose as an example I had a Postgres
table called &lt;span class=&quot;code&quot;&gt;users&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;
create table users (
    id serial primary key,
    first_name varchar(40),
    last_name  varchar(40)
);
&lt;/pre&gt;
&lt;p&gt;…and I needed to count the number of users with multiple last names. People
from Spanish speaking countries, like my wife, often have two last names.
Because I was in a rush and had to get an answer quickly, I turned to
ActiveRecord. This simple Ruby script ran a SQL query and also a bit of Ruby
post-processing to find the number of users with multiple last names:&lt;/p&gt;
&lt;pre style=&quot;background-color:#ffffff;&quot;&gt;
&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;user_groups &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;= &lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;User&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;.all.partition &lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;do &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;user&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;|
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;  user.last_name.split.size &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;gt; &lt;/span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;/span&gt;&lt;span style=&quot;color:#a71d5d;&quot;&gt;end
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Found &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{user_groups.first.size}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; users with more than one last name.&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;puts &lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt;Found &lt;/span&gt;&lt;span style=&quot;color:#000000;&quot;&gt;#{user_groups.last.size}&lt;/span&gt;&lt;span style=&quot;color:#008080;&quot;&gt; users with one last name.&lt;/span&gt;&lt;span style=&quot;color:#4f5b66;&quot;&gt;&amp;quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Ruby and ActiveRecord worked brilliantly. I was done. Neither the language nor
the tools got in my way and I had the quick answer I needed. After just five
minutes I moved on to more important work.&lt;/p&gt;
&lt;h2&gt;Time to Exercise My Mind&lt;/h2&gt;
&lt;p&gt;I had a quick answer, but didn’t learn anything. I realized that if I spent all
of my time getting my work done as quickly as possible and never learned
anything new, I’d fall behind in the long run.&lt;/p&gt;
&lt;p&gt;Because this task was so simple, I decided to try to write the same report
using Rust instead of Ruby. But how? Rust is a much more complex, low level
language than Ruby is. How in the world could I learn about its type system,
its borrow checker, its compiler/build tools, its debugging tools and, of
course, its language syntax without spending months and months reading books?&lt;/p&gt;
&lt;p&gt;The answer was just to try it. And what better way to try a new language than
to work on a simple task like this. It was time for my daily exercise.&lt;/p&gt;
&lt;p&gt;First, I installed &lt;a href=&quot;https://www.rust-lang.org/en-US/install.html&quot;&gt;Rust&lt;/a&gt;, poked
around the &lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/index.html&quot;&gt;The Rust Programming
Language&lt;/a&gt; book a bit,
and read the excellent &lt;a href=&quot;http://diesel.rs/guides/getting-started/&quot;&gt;Diesel
tutorial&lt;/a&gt;. Rust has great
documentation and getting up to speed with this extremely complex language is
just a matter of time, focus and attention. Then I rewrote that simple
Ruby/ActiveRecord report script above using Rust and Diesel. Here’s how I did
it.&lt;/p&gt;
&lt;h2&gt;A New Rust Project&lt;/h2&gt;
&lt;p&gt;To get started, I created a new Rust project using
&lt;a href=&quot;https://doc.rust-lang.org/cargo/guide/&quot;&gt;Cargo&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
$ cargo new last_names --bin
     Created binary (application) `last_names` project
$ cd last_names
$ cargo build
   Compiling last_names v0.1.0 (file:///Users/pat/path/to/last_names)
    Finished dev [unoptimized + debuginfo] target(s) in 7.68 secs
$ target/debug/last_names
Hello, world!
&lt;/pre&gt;
&lt;p&gt;As you can see, Cargo got me started quickly, and I was able to print “Hello
World” with just a few commands.&lt;/p&gt;
&lt;p&gt;Cargo placed the source code in a Rust file called src/main.rs, which looks
like this:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/hello-world.png&quot;/&gt;
&lt;p&gt;As a comparison, I show the equivalent Ruby code below in pink. Pretty simple.&lt;/p&gt;
&lt;h2&gt;From Gemfile to Cargo.toml&lt;/h2&gt;
&lt;p&gt;I knew my script needed to connect to Postgres and execute a SQL statement, so
I added Diesel as a dependency to my Cargo.toml file:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/cargo-toml.png&quot;/&gt;
&lt;p&gt;Cargo is a dependency manager similar to Ruby’s &lt;a href=&quot;https://bundler.io&quot;&gt;Bundler&lt;/a&gt;.
The Cargo.toml file lists the Rust libraries, or “crates,” that my script will
use. It plays the same role as the Gemfile does for Ruby projects.&lt;/p&gt;
&lt;p&gt;Then I installed Diesel by running “cargo build” again:&lt;/p&gt;
&lt;pre&gt;
$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading diesel v1.3.0
 Downloading pq-sys v0.4.5

etc…

  Compiling diesel_derives v1.3.0
   Compiling diesel v1.3.0
   Compiling last_names v0.1.0 (file:///Users/pat/path/to/last_names)
    Finished dev [unoptimized + debuginfo] target(s) in 47.30 secs
&lt;/pre&gt;
&lt;h2&gt;Connecting to Postgres&lt;/h2&gt;
&lt;p&gt;Ok now I’m ready to start working on my report code, back in main.rs. The first
thing I need to do is open a connection to Postgres. After that, I can figure
out how to execute my report.&lt;/p&gt;
&lt;p&gt;Here’s how I did it - again I show the Rust code in grey and the equivalent
Ruby code below in pink:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/connect.png&quot;/&gt;
&lt;p&gt;The Rust code is fairly simple and easy to understand: It just passes a
Postgres connection string to &lt;span
class=&quot;code&quot;&gt;PgConnection::establish&lt;/span&gt;. One interesting and important
detail here is the call to &lt;span class=&quot;code&quot;&gt;expect&lt;/span&gt;. &lt;span
class=&quot;code&quot;&gt;PgConnection::establish&lt;/span&gt; returns a &lt;span
class=&quot;code&quot;&gt;ConnectionResult&lt;T&gt;&lt;/span&gt; value, which is derived from the
&lt;a href=&quot;https://doc.rust-lang.org/std/result/enum.Result.html&quot;&gt;Result enum&lt;/a&gt;:&lt;/p&gt;
&lt;img width=&quot;200&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/result.png&quot;/&gt;
&lt;p&gt;As &lt;em&gt;The Rust Programming Language&lt;/em&gt;
&lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html&quot;&gt;explains&lt;/a&gt;,
&lt;span class=&quot;code&quot;&gt;expect&lt;/span&gt; checks whether the result value contains &lt;span
class=&quot;code&quot;&gt;Ok&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;Err&lt;/span&gt;. If it contains &lt;span
class=&quot;code&quot;&gt;Err&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;expect&lt;/span&gt; prints out the given
error message.&lt;/p&gt;
&lt;p&gt;Assuming my Postgres server is up and running and contains a database called
“names,” I can now compile, run my Rust script and connect to Postgres:&lt;/p&gt;
&lt;pre&gt;
$ cargo build
   Compiling last_names v0.1.0 (file:///Users/pat/path/to/last_names)
    Finished dev [unoptimized + debuginfo] target(s) in 0.71 secs
$ target/debug/last_names
Connected!
&lt;/pre&gt;
&lt;p&gt;Stepping back for a moment, the Ruby and Rust versions of this code are
actually very similar. However, the Rust version is a bit more complex because
I have to explicitly handle the possibility that &lt;span
class=&quot;code&quot;&gt;PgConnection::establish&lt;/span&gt; might return an error. In Ruby I
can ignore this possibility, although my script would crash if &lt;span
class=&quot;code&quot;&gt;ActiveRecord::Base.establish_connection&lt;/span&gt; ran into a problem
and raised an exception.&lt;/p&gt;
&lt;h2&gt;Inspecting My Postgres Column Types&lt;/h2&gt;
&lt;p&gt;Using Ruby, ActiveRecord automatically inspects my database table and creates
methods on my model class for each column. But in Rust, I have to type in code
that declares each Postgres table and column I plan to use. (Actually, Diesel
can also inspect my database columns automatically using the &lt;span
class=&quot;code&quot;&gt;infer_schema!&lt;/span&gt; macro, but as a beginner I find it easier to
type this information in explicitly.)&lt;/p&gt;
&lt;p&gt;Fortunately, Diesel provides a command line tool that makes this easy:&lt;/p&gt;
&lt;pre&gt;
$ diesel print-schema --database-url=postgres://pat@patshaughnessy.net:5432/names --whitelist users
table! {
    users (id) {
        id -&gt; Int4,
        first_name -&gt; Nullable&amp;lt;Varchar&gt;,
        last_name -&gt; Nullable&amp;lt;Varchar&gt;,
    }
}
&lt;/pre&gt;
&lt;p&gt;The diesel tool printed out a series of Rust macros that declare the name of my
Postgres table, and the names and types of each of the table’s columns. Notice
that I provided two command line parameters: the Postgres connection string and
my database table name.&lt;/p&gt;
&lt;p&gt;The Diesel macros resemble the original SQL definition of my Postgres table:&lt;/p&gt;
&lt;img width=&quot;676&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/sql-to-macro.png&quot;/&gt;
&lt;p&gt;Diesel used &lt;span class=&quot;code&quot;&gt;Int4&lt;/span&gt; for the primary key column, and
&lt;span class=&quot;code&quot;&gt;Nullable&amp;lt;Varchar&amp;gt;&lt;/span&gt; for each of the Postgres varchar
string columns. &lt;span class=&quot;code&quot;&gt;Nullable&lt;/span&gt; must mean that my Postgres
SQL schema allows null values for &lt;span class=&quot;code&quot;&gt;first_name&lt;/span&gt; and
&lt;span class=&quot;code&quot;&gt;last_name&lt;/span&gt;. In other words, it means that I didn’t
specify &lt;span class=&quot;code&quot;&gt;NOT NULL&lt;/span&gt; for these columns in my
&lt;span class=&quot;code&quot;&gt;CREATE TABLE&lt;/span&gt; command.&lt;/p&gt;
&lt;h2&gt;Creating a Model&lt;/h2&gt;
&lt;p&gt;Next, using these macros as a guide, I wrote a Rust struct to serve as my
database model. An instance of this struct was going to represent each row in
my Postgres table:&lt;/p&gt;
&lt;img width=&quot;692&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/macro-to-model.png&quot;/&gt;
&lt;p&gt;Just as Diesel mapped each Postgres column type to a Rust macro with the
corresponding type, I had to choose a Rust type for each Postgres column in my
new struct. For the id column, I picked Rust’s &lt;span class=&quot;code&quot;&gt;i32&lt;/span&gt;
integer type. This made sense because the &lt;span class=&quot;code&quot;&gt;Int4&lt;/span&gt;
implied a 4 byte or 32 bit integer value. And for each of the string columns, I
chose the Rust &lt;span class=&quot;code&quot;&gt;String&lt;/span&gt; type.&lt;/p&gt;
&lt;p&gt;Finally, I pasted all of this into my main.rs source code file, as follows:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/model.png&quot;/&gt;
&lt;p&gt;Reading this over, the Ruby version is much more concise. In Rust I specified
the name and type of each column, while in Ruby ActiveRecord figured all of
that out for me. (Although as I mentioned above, I could have asked Diesel to
detect the column types automatically also.)&lt;/p&gt;
&lt;h2&gt;Trying to Execute a SQL Statement in Rust&lt;/h2&gt;
&lt;p&gt;Now after all of this setup, I’m finally ready to execute my report. Here’s the
Rust code I wrote inside the &lt;span class=&quot;code&quot;&gt;main()&lt;/span&gt; function, following the call to
&lt;span class=&quot;code&quot;&gt;PgConnection::establish&lt;/span&gt;:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/trying.png&quot;/&gt;
&lt;p&gt;It took me a while to figure out the proper syntax, especially the bits that
use generic type notation, like &lt;span class=&quot;code&quot;&gt;Vec&amp;lt;User&amp;gt;&lt;/span&gt; and &lt;span
class=&quot;code&quot;&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/span&gt;. Also the &lt;span
class=&quot;code&quot;&gt;.collect::&amp;lt;Vec&amp;lt;&amp;amp;str&amp;gt;&amp;gt;()&lt;/span&gt; code seemed a bit odd to me as
well, because it includes a type inside a function name. The reason for this
complex notation is that the &lt;span class=&quot;code&quot;&gt;collect&lt;/span&gt; function
converts the iterator returned by &lt;span class=&quot;code&quot;&gt;split&lt;/span&gt; into an
array, but the Rust compiler needs to know what type of values will be in that
array. Rust normally uses type inference to figure this out, but in this case
there’s no way for it to know. Therefore, I needed to specify the &lt;span
class=&quot;code&quot;&gt;Vec&amp;lt;&amp;amp;str&amp;gt;&lt;/span&gt; type manually, telling Rust I wanted an array of
string references.&lt;/p&gt;
&lt;p&gt;But in the end I was surprised how similar the Rust and Ruby versions of this
code are! Both load all the user records into memory in a similar way, although
the Rust version has to check for errors explicitly. And both Rust and Ruby use
&lt;span class=&quot;code&quot;&gt;partition&lt;/span&gt; with a closure that checks whether each
last name string contains multiple words or not, by calling &lt;span
class=&quot;code&quot;&gt;split&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;I was very excited to try this out, so I ran the Rust compiler:&lt;/p&gt;
&lt;pre&gt;
$ cargo build
   Compiling last_names v0.1.0 (file:///Users/pat/path/to/last_names)

error[E0277]: the trait bound `*const str:
            diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, _&gt;`
            is not satisfied

  --&gt; src/main.rs:30:25
   |
30 |     let results = users.load::&amp;lt;User&gt;(&amp;connection).expect(
   |                         ^^^^ the trait
   |                              `diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Nullable
   |                              &amp;lt;diesel::sql_types::Text&gt;, _&gt;` is not implemented for `*const str`
   |
   = help: the following implementations were found:
             &amp;lt;*const str as diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Text, DB&gt;&gt;
             &amp;lt;*const [u8] as diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Binary, DB&gt;&gt;
   = note: required because of the requirements on the impl of `diesel::deserialize::FromSql&amp;lt;diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, _&gt;` for `std::string::String`
   = note: required because of the requirements on the impl of `diesel::Queryable&amp;lt;diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, _&gt;` for `std::string::String`
   = note: required because of the requirements on the impl of `diesel::Queryable&amp;lt;(diesel::sql_types::Integer, diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;), _&gt;` for `(i32, std::string::String, std::string::String)`
   = note: required because of the requirements on the impl of `diesel::Queryable&amp;lt;(diesel::sql_types::Integer, diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;, diesel::sql_types::Nullable&amp;lt;diesel::sql_types::Text&gt;), _&gt;` for `User`
   = note: required because of the requirements on the impl of `diesel::query_dsl::LoadQuery&amp;lt;_, User&gt;` for `users::table`

error: aborting due to previous error

error: Could not compile `last_names`.

To learn more, run the command again with --verbose.
&lt;/pre&gt;
&lt;p&gt;Ugh - what happened? I started to realize how difficult error messages from the
Rust compiler can be to understand, especially for beginners like me.&lt;/p&gt;
&lt;p&gt;And I certainly didn’t want to try the “—verbose” option the Rust compiler
suggested. This message was already verbose enough!&lt;/p&gt;
&lt;h2&gt;Rust’s Type System Keeps Me Out of Trouble&lt;/h2&gt;
&lt;p&gt;After a while, I realized what the problem was. Reading the error message again
more carefully, I saw the line:&lt;/p&gt;
&lt;pre&gt;
diesel::sql_types::Nullable&lt;diesel::sql_types::Text&gt; ...is not satisfied
&lt;/pre&gt;
&lt;p&gt;Ah - the problem must have to do with the &lt;span class=&quot;code&quot;&gt;Nullable&lt;/span&gt;
macro the Diesel utility generated for me. That indicated that my underlying
Postgres column allowed null values. At first, I thought maybe I should add
&lt;span class=&quot;code&quot;&gt;NOT NULL&lt;/span&gt; to my Postgres table and prevent users with
null last names. That must be the answer.&lt;/p&gt;
&lt;p&gt;But thinking about this some more, I realized that maybe having no last name is
a valid state. That some people really don’t have last names… Bono, Lady Gaga,
or Sting. Or maybe these are their last names and they have no first names?
Either way it seemed to me that my report code should handle null values, and
that it shouldn’t make assumptions about what’s in the data set.&lt;/p&gt;
&lt;p&gt;I decided to adapt my Rust code to make this work, and to do that I needed a
way of saving null values in my User struct. The problem, what the Rust
compiler was trying to tell me, was that my User struct could not handle nulls
as written. I needed to use an option type instead:&lt;/p&gt;
&lt;img width=&quot;693&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/option-model.png&quot;/&gt;
&lt;p&gt;Like the &lt;span class=&quot;code&quot;&gt;Result&lt;/span&gt; enum we saw above, &lt;span
class=&quot;code&quot;&gt;Option&lt;/span&gt; is an enum that can contain either &lt;span
class=&quot;code&quot;&gt;Some&lt;/span&gt; or &lt;span class=&quot;code&quot;&gt;None&lt;/span&gt;… i.e. a null value:&lt;/p&gt;
&lt;img width=&quot;170&quot; src=&quot;http://patshaughnessy.net/assets/2018/6/9/option.png&quot;/&gt;
&lt;p&gt;To learn more about the &lt;span class=&quot;code&quot;&gt;Option&lt;/span&gt; type, read &lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values&quot;&gt;Chapter
6&lt;/a&gt;
from &lt;em&gt;The Rust Programming Language&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;After changing my &lt;span class=&quot;code&quot;&gt;User&lt;/span&gt; struct, I then had to rework
the closure inside of &lt;span class=&quot;code&quot;&gt;partition&lt;/span&gt;. Here’s what I ended
up with:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/unwrap.png&quot;/&gt;
&lt;p&gt;I wrote &lt;span class=&quot;code&quot;&gt;if let Some(ref name)&lt;/span&gt; to check whether or not
the last name of each user struct was null. In other words, I “unwrapped” the
last name. The &lt;span class=&quot;code&quot;&gt;ref&lt;/span&gt; keyword satisfies Rust’s borrow
checker, which enforces Rust’s unique and innovative memory ownership model.
Without &lt;span class=&quot;code&quot;&gt;ref&lt;/span&gt;, the Rust compiler would give me another
error: “cannot move out of borrowed content.” To learn more about Rust’s
ownership model, see &lt;a href=&quot;https://doc.rust-lang.org/book/second-edition/ch04-00-understanding-ownership.html&quot;&gt;Chapter
4&lt;/a&gt;
of &lt;em&gt;The Rust Programming Language&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Finally, I compiled and ran my Rust code, and saw the results I expected:&lt;/p&gt;
&lt;pre&gt;
$ target/debug/last_names
Connected!
Found 20 users with more than one last name.
Found 80 users with one last name.
&lt;/pre&gt;
&lt;p&gt;As a test, I tried adding a user with no last name and got the expected results - the
user with no last name was counted as if they had one:&lt;/p&gt;
&lt;pre&gt;
$ psql names
psql (9.6.3)
Type &quot;help&quot; for help.
names=# INSERT INTO users (first_name, last_name) VALUES ('Bono', NULL);
INSERT 0 1
names=# \q

$ target/debug/last_names
Connected!
Found 20 users with more than one last name.
Found 81 users with one last name.
&lt;/pre&gt;
&lt;p&gt;But when I reran my original Ruby code with a null last name, it crashed!&lt;/p&gt;
&lt;pre&gt;
$ ruby main.rb
Connected.
main.rb:18:in `block in \&lt;main\&gt;': undefined method `split' for nil:NilClass (NoMethodError)
&lt;/pre&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/6/9/fix-ruby.png&quot;/&gt;
&lt;p&gt;Rewriting my Ruby code in Rust revealed a bug I never knew I had. As shown
above, I had to rework my Ruby code to check for a null last name inside the
block, similar to what I wrote in Rust. Even though it required more typing and
more work, Rust’s strict type system told me my code might crash at compile
time, while Ruby didn't tell me anything was wrong until runtime.&lt;/p&gt;
&lt;h2&gt;Rust vs. Ruby&lt;/h2&gt;
&lt;p&gt;In the end I was able to rewrite my Ruby code in Rust and get the same results.
&lt;a href=&quot;https://gist.github.com/patshaughnessy/db735e90d58376fdd550b35838aa5339&quot;&gt;This
gist&lt;/a&gt;
contains the Rust code I ended up with, if you’re interested in trying this
yourself.&lt;/p&gt;
&lt;p&gt;Writing the same algorithm in both languages and comparing, I noticed a few
obvious differences. First, the runtime execution performance was far superior
using Rust. I was able to load and process large sets of User records much,
much faster using Rust. But development performance was better using Ruby.  The
speed at which I was able to write working code was faster using Ruby.  It took
minutes to write the Ruby version, but hours to write the Rust version.  Of
course, I’m a Rust novice. An experienced Rust developer who knew what they
were doing could probably have written this in just a few minutes as well.
Second, Ruby is concise, while Rust is verbose. It took much more typing to
write Rust. But this extra thoroughness led me to find a bug in my Ruby code I
never knew I had.&lt;/p&gt;
&lt;p&gt;Which language is better? Neither. Ruby and Rust are different tools that are
best used in different circumstances.&lt;/p&gt;
&lt;p&gt;In the end what matters is that I learned something. One language isn’t better
than another - but now I’m a better developer because I took the time to learn
something new. By taking 5 hours instead of 5 minutes to accomplish a simple
task, I gained valuable insight and knowledge. I gave my mind the exercise it
was so hungry for. And thankfully no one noticed it took me 5 hours to run a
report that should have taken 5 minutes.&lt;/p&gt;
</content></entry><entry><title>How Rust Implements Tagged Unions</title><link href="http://patshaughnessy.net/2018/3/15/how-rust-implements-tagged-unions" rel="alternate"></link><id href="http://patshaughnessy.net/2018/3/15/how-rust-implements-tagged-unions" rel="alternate"></id><published>2018-03-15T00:00:00Z</published><updated>2018-03-15T00:00:00Z</updated><category>Rust</category><author><name>Pat Shaughnessy</name></author><summary type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/covers.png&quot;&gt;&lt;br/&gt;
&lt;i&gt; &lt;small&gt;(&lt;a href=&quot;https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131101633/ref=pd_lpo_sbs_14_img_1?_encoding=UTF8&amp;psc=1&amp;refRID=J7H21QEX2A2NN3Y6EG00&quot;&gt;The C Programming Language&lt;/a&gt; and &lt;a href=&quot;https://nostarch.com</summary><content type="html">&lt;div style=&quot;float: left; padding: 8px 30px 40px 0px; text-align: center; line-height:18px&quot;&gt;
  &lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/covers.png&quot;&gt;&lt;br/&gt;
&lt;i&gt; &lt;small&gt;(&lt;a href=&quot;https://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131101633/ref=pd_lpo_sbs_14_img_1?_encoding=UTF8&amp;psc=1&amp;refRID=J7H21QEX2A2NN3Y6EG00&quot;&gt;The C Programming Language&lt;/a&gt; and &lt;a href=&quot;https://nostarch.com/Rust&quot;&gt;The Rust Programming Language&lt;/a&gt;)&lt;/small&gt;&lt;/i&gt; 
&lt;/div&gt;
&lt;p&gt;Rust &lt;a href=&quot;https://www.rust-lang.org/en-US/&quot;&gt;describes itself&lt;/a&gt; as:&lt;/p&gt;
&lt;blockquote&gt;
…a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.
&lt;/blockquote&gt;
&lt;p&gt;Of course, this is in contrast to C, a different systems programming language
that encourages segfaults and makes no guarantees at all about thread safety.
Rust improves on C in many ways, most famously with its innovative ownnership
model for managing memory.&lt;/p&gt;
&lt;p&gt;Another less obvious improvement Rust makes to C has to do with the &lt;span
class=&quot;code&quot;&gt;union&lt;/span&gt; keyword. The Rust compiler implements &lt;em&gt;tagged
unions&lt;/em&gt;, which prevent you from crashing your program by initializing a union
with one variant and accessing it with another. &lt;del&gt;But the Rust doesn’t include
the &lt;span class=&quot;code&quot;&gt;union&lt;/span&gt; keyword at all&lt;/del&gt;; instead, Rust
uses &lt;span class=&quot;code&quot;&gt;enum&lt;/span&gt; to improve on both C enums and C unions at
the same time.&lt;/p&gt;
&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;
&lt;p&gt;(Update: I heard &lt;a href=&quot;https://twitter.com/josh_triplett/status/974312496717742080&quot;&gt;on
Twitter&lt;/a&gt; and in
the comments that Rust does include untagged unions for use in FFI to
interoperate with C, or for unsafe code building custom unions.)&lt;/p&gt;
&lt;p&gt;Not sure what a tagged union is? Or why it’s an improvement over an old
fashioned C union? Today I’ll explain. First I’ll start with a quick review of
C unions, how they work and why they are dangerous. Then I’ll show you how Rust
enums improve on them.&lt;/p&gt;
&lt;h2&gt;C Unions&lt;/h2&gt;
&lt;p&gt;Unions are one of the most dangerous features of C. Here’s an example:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/union1.png&quot;/&gt;
&lt;p&gt;Here the union &lt;span class=&quot;code&quot;&gt;num_or_str&lt;/span&gt; saves either a number or
a character pointer but not both. (A union can contain any number of members;
for simplicity my example union has only two.) On the right I show how the C
compiler would allocate memory for an instance of &lt;span
class=&quot;code&quot;&gt;num_or_str&lt;/span&gt;. It allocates enough memory to hold the longest
value in the union, but not both values at the same time. The integer is a
short, meaning it occupies 16 bits or two bytes, and the string is a char
pointer which takes 64 bits or 8 bytes using a modern 64-bit CPU. The two
options for what might be stored in the union, &lt;span class=&quot;code&quot;&gt;num&lt;/span&gt;
and &lt;span class=&quot;code&quot;&gt;str&lt;/span&gt; in this example, are known as &lt;em&gt;variants&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Why C Unions Are Dangerous&lt;/h2&gt;
&lt;p&gt;Unions are dangerous because you, the C programmer, need to remember which
variant you set in the union. If you save one type of value but then access the
other, your program will crash.&lt;/p&gt;
&lt;p&gt;For example this code works fine:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code1.png&quot;/&gt;
&lt;p&gt;But if you forget &lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt; contains a number, and use
&lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt; as a string instead, your program will
crash:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code2.png&quot;/&gt;
&lt;p&gt;Notice the C compiler didn’t help me here at all. It didn’t display any sort of
warning or error when I wrote &lt;span class=&quot;code&quot;&gt;a_number.str&lt;/span&gt;. It
silently allowed me to write dangerous code; in fact, union syntax encouraged
me to introduce a segmentation fault.&lt;/p&gt;
&lt;p&gt;Writing C code with unions is like driving very fast down a highway full of
potholes. You might be the best driver in the world, but eventually you’re
going to hit one of the holes and crash.&lt;/p&gt;
&lt;h2&gt;Tagged Unions&lt;/h2&gt;
&lt;p&gt;C programmers have been writing code with unions for years - for decades in
fact. How have they avoided this problem? There must be a safe way of writing C
code with unions.&lt;/p&gt;
&lt;p&gt;The most common and robust solution is to keep track of which union variant is
valid using an integer value saved right next to the union in memory. This
integer is known as a tag, and the combination of the tag and the union is a
&lt;em&gt;tagged union&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Here’s an example:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/tagged_union.png&quot;/&gt;
&lt;p&gt;On the right side I’ve allocated some memory right before the union for the tag
using a struct. C structs, unlike unions, allocate enough memory to store all
of their members at once. Note: Using two bytes to save a small integer value
is unnecessary. C programs often use only one byte, or even represent the
integer value using a bit mask inside the union’s values. But the principle
remains the same.&lt;/p&gt;
&lt;p&gt;Now when I save an integer in an instance of the union I can also set the tag
to the value 1, for example, which I decide will mean that &lt;span
class=&quot;code&quot;&gt;a_number&lt;/span&gt; contains a number:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code3.png&quot;/&gt;
&lt;p&gt;And if I want to save a string instead, I set the tag to 2, for example:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code4.png&quot;/&gt;
&lt;p&gt;Later when I access the tagged union, I first check the tag before deciding
which variant I can access:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/c-code5.png&quot;/&gt;
&lt;p&gt;Of course, tagged unions are not foolproof. I invented the tag values 1 and 2
and wrote the code that checks for them. There’s nothing to prevent me from
forgetting to save the tag value, saving the wrong tag value or misinterpreting
the tag value when I later read it. And, if I ever add new variants to the
union, I have to add a new branch to every &lt;span class=&quot;code&quot;&gt;if&lt;/span&gt;
statement in my app that checks the tags, handling the new value. Needless to
say, the C compiler won’t help me find those &lt;span class=&quot;code&quot;&gt;if&lt;/span&gt;
statements or check whether I’ve covered all the possible tag values.&lt;/p&gt;
&lt;p&gt;I’m a forgetful and  easily distracted person. I need a programming language
that will keep me out of trouble. Even with tagged unions I’m sure I would
write dangerous, crashing C code before long.&lt;/p&gt;
&lt;h2&gt;Tagged Unions in Rust&lt;/h2&gt;
&lt;p&gt;Rust implements tagged unions using the &lt;span class=&quot;code&quot;&gt;enum&lt;/span&gt; keyword.
For example, to declare a Rust enum type equivalent to the C tagged union above
I write:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/rust-enum1.png&quot;/&gt;
&lt;p&gt;The questions for today are: Why are enums equivalent to tagged unions in C?
And: What should I draw on the right side? What would I see if I could find and
examine an enum in the memory space of a running Rust process?&lt;/p&gt;
&lt;h2&gt;Saving a Rust Enum&lt;/h2&gt;
&lt;p&gt;To find out, let’s create an instance of &lt;span class=&quot;code&quot;&gt;NumOrStr&lt;/span&gt;:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/rust-enum2.png&quot;/&gt;
&lt;p&gt;Notice that instead of 4, I’ve saved a more recognizable value, 1234. Now, if I
compile it with the &lt;span class=&quot;code&quot;&gt;-—emit asm&lt;/span&gt; flag:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/rust-emit-asm.png&quot;/&gt;
&lt;p&gt;…Rust generates a file called union.s which contains the assembly language
version of my program. If I open union.s and search for 1234, the integer value
I saved above, I see:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/asm1.png&quot;/&gt;
&lt;p&gt;I’ve found it; here are the x86 assembly language instructions that initialize
&lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt;. These show me exactly how Rust represents
enums in memory, how Rust implements tagged unions.&lt;/p&gt;
&lt;p&gt;The only problem is… I have no idea what this means!&lt;/p&gt;
&lt;h2&gt;The movw x86 Instruction&lt;/h2&gt;
&lt;p&gt;What does &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt; mean? And what about &lt;span
class=&quot;code&quot;&gt;-32(%rbp)&lt;/span&gt;?&lt;/p&gt;
&lt;p&gt;It turns out x86 assembly language isn’t that hard to follow, once you learn
the basic syntax. For a quick introduction, see my article from 2016: &lt;a href=&quot;http://patshaughnessy.net/2016/11/26/learning-to-read-x86-assembly-language&quot;&gt;Learning
to Read x86 Assembly
Language&lt;/a&gt;.
Intel, the company that built the microprocessor inside my Mac, defines the
&lt;span class=&quot;code&quot;&gt;mov&lt;/span&gt; instruction to mean “move.” (Note: the
instructions I show here that &lt;span class=&quot;code&quot;&gt;rustc —emit asm&lt;/span&gt;
generates aren’t written using Intel x86 syntax, but with GAS x86 syntax
instead.)&lt;/p&gt;
&lt;p&gt;Here’s a diagram showing what the first &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt;
instruction moves:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/asm2.png&quot;/&gt;
&lt;p&gt;It turns out that &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt; stands for “move a word.” A
word is defined as 16 bits, or 2 bytes. There are a few different variations on
move, &lt;span class=&quot;code&quot;&gt;movb&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt;, &lt;span
class=&quot;code&quot;&gt;movl&lt;/span&gt;, &lt;span class=&quot;code&quot;&gt;movq&lt;/span&gt;, which move 1
byte, 2 bytes, 4 bytes or 8 bytes respectively.&lt;/p&gt;
&lt;p&gt;Next, the &lt;span class=&quot;code&quot;&gt;$&lt;/span&gt; notation indicates a literal value -  in
this case zero: &lt;span class=&quot;code&quot;&gt;$0&lt;/span&gt;. Now we can see the first
instruction above is moving 2 bytes containing the value zero. Similarly, the
second instruction is moving 2 bytes containing the value 1234:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/asm3.png&quot;/&gt;
&lt;h2&gt;The rbp Register&lt;/h2&gt;
&lt;p&gt;But where are these &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt; instructions moving these
values to? To understand that we need to understand the odd &lt;span
class=&quot;code&quot;&gt;-32(%rbp)&lt;/span&gt; syntax on the right side of the instructions. The
&lt;span class=&quot;code&quot;&gt;%&lt;/span&gt; sign indicates a register inside my Mac’s
microprocessor, in this case the “base pointer” register. So &amp;quot;bp&amp;quot; means &amp;quot;base
pointer.&amp;quot; And the “r” prefix in &amp;quot;rbp&amp;quot; means the move instruction is using all 8
bytes (64 bits) of this register’s value.&lt;/p&gt;
&lt;p&gt;The &lt;span class=&quot;code&quot;&gt;-32(%rbp)&lt;/span&gt; notation calculates a memory address
for the instruction using the contents of the &lt;span class=&quot;code&quot;&gt;%rbp&lt;/span&gt;
register - in this case the address of where to move the data to. The
expression &lt;span class=&quot;code&quot;&gt;-32(%rbp)&lt;/span&gt; in English means: “Take the 64
bit memory address value from the base pointer register, and subtract 32 from
it.”&lt;/p&gt;
&lt;p&gt;Compiled Rust programs - all programs really - that run on the x86 platform
store values for local variables on the stack, using the base pointer register
in this fashion. The base pointer, as it’s name indicates, stores the base
address of my program's current stack frame. Each local variable in my code,
for example &lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt;, is saved somewhere on the
stack. If you’re not familiar with the concept of a stack, think of it as a
convenient place for quickly saving and retrieving values while your program is
running.&lt;/p&gt;
&lt;h2&gt;How Rust Saves an Integer Enum Variant&lt;/h2&gt;
&lt;p&gt;Taking a step back for a moment, here’s what we’ve learned so far. When I save
an enum value containing an integer, Rust saves &lt;em&gt;two&lt;/em&gt; values, 0 and 1234:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save1.png&quot;/&gt;
&lt;p&gt;What does the &lt;span class=&quot;code&quot;&gt;0&lt;/span&gt; mean? Rust records a zero to indicate
that &lt;span class=&quot;code&quot;&gt;a_number&lt;/span&gt; uses the &lt;span
class=&quot;code&quot;&gt;NumOrStr::Num&lt;/span&gt; variant. In other words, &lt;span
class=&quot;code&quot;&gt;a_number&lt;/span&gt; is a tagged union, and the zero value is the tag.
We know the tag occupies 2 bytes because of the &lt;span class=&quot;code&quot;&gt;movw&lt;/span&gt;
instruction above. The integer value itself, &lt;span class=&quot;code&quot;&gt;1234&lt;/span&gt;,
also takes 2 bytes because I declared it using &lt;span
class=&quot;code&quot;&gt;Num(i16)&lt;/span&gt;, and we saw Rust used a movw to save that also.&lt;/p&gt;
&lt;h2&gt;How Rust Saves an String Enum Variant&lt;/h2&gt;
&lt;p&gt;But what about the other variant, the string? When I save a string in &lt;span
class=&quot;code&quot;&gt;NumOrStr&lt;/span&gt;, what does Rust do? To find out, I’ll replace my
main function from above with this line of code:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save2.png&quot;/&gt;
&lt;p&gt;The I’ll compile it again using the &lt;span class=&quot;code&quot;&gt;--emit asm&lt;/span&gt;
option. Now I find this assembly language code in the union.s file:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/asm4.png&quot;/&gt;
&lt;p&gt;Unfortunately this code snippet is much more complex: It first calls &lt;span
class=&quot;code&quot;&gt;String::from&lt;/span&gt; passing a string literal, and then saves the
string into the enum via a method called &lt;span
class=&quot;code&quot;&gt;drop_in_place&lt;/span&gt;. This is much harder to understand.&lt;/p&gt;
&lt;p&gt;Rather than trying to figure this out, I decided to debug my Rust sample
program using LLDB, and inspect the memory &lt;span class=&quot;code&quot;&gt;a_string&lt;/span&gt;
occupies. I found that Rust used 26 bytes to represent the string variant,
starting with a 16 bit word containing 1:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save3.png&quot;/&gt;
&lt;p&gt;This is again the tag; in this case &lt;span class=&quot;code&quot;&gt;1&lt;/span&gt; means &lt;span
class=&quot;code&quot;&gt;a_string&lt;/span&gt; uses the &lt;span class=&quot;code&quot;&gt;NumOrStr::Str&lt;/span&gt;
variant. Following this I found a pointer to the string itself:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save4.png&quot;/&gt;
&lt;p&gt;Pointers on a 64-bit microprocessor occupy 8 bytes and contain the memory
address of something, in this case my string &amp;quot;This is a test.” After the
pointer I found two 64 bit values, each containing 15:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save5.png&quot;/&gt;
&lt;p&gt;These are two attributes of the string: its capacity and length. By inspecting
my process's memory I’ve started to learn a bit about how Rust manages memory
for strings.&lt;/p&gt;
&lt;p&gt;But what’s important for me today is the first word, the value 1. Again, we see
the same pattern. Rust saves an integer value, the tag, indicating which
variant this instance of the enum uses. Then Rust saves the enum variant’s
payload in the memory that follows:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/save6.png&quot;/&gt;
&lt;h2&gt;Tagged Unions in Rust and C&lt;/h2&gt;
&lt;p&gt;Let’s review by declaring a tagged union in C and Rust:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/review1.png&quot;/&gt;
&lt;p&gt;On the left using C, I have to include the tag explicitly in a surrounding
struct. Rust handles this for me automatically, saving the tag value inside the
enum alongside the enum’s value. The code looks very different, but as we saw above
the implementations are_ identical_.&lt;/p&gt;
&lt;p&gt;Using a tagged union looks somewhat similar in C and Rust:&lt;/p&gt;
&lt;img src=&quot;http://patshaughnessy.net/assets/2018/3/15/review2.png&quot;/&gt;
&lt;p&gt;But there are very important differences here! Using C, I need to remember to
check the tag and to use the proper variant inside the union. The Rust
compiler, on the other hand, checks the tag for me automatically and won’t
allow me to access the wrong variant. The code inside of &lt;span class=&quot;code&quot;&gt;if
let&lt;/span&gt; will never be executed unless the internal tag value matches the
&lt;span class=&quot;code&quot;&gt;NumOrStr::Num&lt;/span&gt; variant.&lt;/p&gt;
&lt;p&gt;Under the hood, the two languages implement tagged unions the same way. But
writing code in C and Rust is very different. C encourages me to write
dangerous, crashing code, while Rust prevents me from writing dangerous code in
the first place.&lt;/p&gt;
</content></entry></feed>